{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Deprecated! Due to the amount of integration required to support console tooling via the MVC, and because better, more standalone solutions exist , we will not be maintaining zend-mvc-console long term . We strongly urge developers to start migrating their MVC-based console tooling to use other libraries, such as zf-console . For use with zend-mvc v3 and up While this component has an initial stable release, please do not use it with zend-mvc releases prior to v3, as it is not compatible. Installation $ composer require zendframework/zend-mvc-console Assuming you are using the component installer , doing so will enable the component in your application, allowing you to immediately start developing console applications via your MVC. Manual installation If you are not using the component installer, you will need to add this component as a module at the start of your module list in your Zend Framework application. If using a vanilla skeleton application, update config/application.config.php : $$$$FENCED_CODE_BLOCK_5dbd78ed9b5cd0.40179441 If using Apigility, update your config/modules.config.php : $$$$FENCED_CODE_BLOCK_5dbd78ed9b6258.75835217 Migration In order to separate the console tooling from zend-mvc and provide it as a standalone package, we needed to make a few changes. See the migration guide for details.","title":"Home"},{"location":"#installation","text":"$ composer require zendframework/zend-mvc-console Assuming you are using the component installer , doing so will enable the component in your application, allowing you to immediately start developing console applications via your MVC.","title":"Installation"},{"location":"#migration","text":"In order to separate the console tooling from zend-mvc and provide it as a standalone package, we needed to make a few changes. See the migration guide for details.","title":"Migration"},{"location":"controllers/","text":"Controllers When using the zend-mvc integration with zend-console, a matched route results in dispatch of an action controller. In this chapter we will learn how ZF2 Controllers can interact with and return output to console window. AbstractConsoleController zend-mvc-console provides a controller implementation for use with zend-mvc , Zend\\Mvc\\Controller\\AbstractConsoleController . The implementation extends from the zend-mvc AbstractActionController , and provides the following functionality: The method setConsole(Zend\\Console\\Adapter\\AdapterInterface $console) allows injecting a console adapter representing the current console environment. By default, the ControllerManager will inject this for you as part of controller instantiation. The method getConsole() allows you to retrieve the current console adapter instance, allowing you to retrieve console capabilities and generate console output. The dispatch() method will throw an exception if invoked in a non-console environment, ensuring that you do not need to do any checks within your action methods for the environment. Interfaces and Collaborators AbstractRestfulController implements each of the following interfaces: Zend\\Stdlib\\DispatchableInterface Zend\\Mvc\\InjectApplicationEventInterface Zend\\EventManager\\EventManagerAwareInterface The composed EventManager will be configured to listen on the following contexts: Zend\\Stdlib\\DispatchableInterface Zend\\Mvc\\Controller\\AbstractConsoleController Zend\\Mvc\\Controller\\AbstractActionController Zend\\Mvc\\Controller\\AbstractController Additionally, if you extend the class, it will listen on the name of the extending class. Handling Console Requests Console requests are very similar to HTTP requests. In fact, they implement a common interface and are created at the same time in the MVC workflow. Console routes match against command line arguments and provide a defaults array, which holds the controller and action keys. These correspond with controller aliases in the ServiceManager , and method names in the controller class. This is analogous to the way HTTP requests are handled under zend-mvc. In this example we'll use the following route: // in file module/Application/config/module.config.php: return [ 'router' => [ 'routes' => [ // HTTP routes are here ], ], 'console' => [ 'router' => [ 'routes' => [ 'list-users' => [ 'options' => [ 'route' => 'show [all|disabled|deleted]:mode users [--verbose|-v]', 'defaults' => [ 'controller' => Application\\Controller\\Index::class, 'action' => 'show-users', ], ], ], ], ], ], /* ... */ ]; This route will match commands such as: $ php public/index.php show users $ php public/index.php show all users $ php public/index.php show disabled users This route maps to the method Application\\Controller\\IndexController::showUsersAction() . Let's add that method to our controller. namespace Application\\Controller; use Application\\Model\\Users; use Zend\\Mvc\\Controller\\AbstractActionController; use Zend\\View\\Model\\ViewModel; class IndexController extends AbstractActionController { private $users; public function __construct(Users $users) { $this->users = $users; } public function indexAction() { return new ViewModel(); // display standard index page } public function showUsersAction() { $request = $this->getRequest(); // Check verbose flag $verbose = $request->getParam('verbose') || $request->getParam('v'); // Check mode $mode = $request->getParam('mode', 'all'); // defaults to 'all' $users = []; switch ($mode) { case 'disabled': $users = $this->users->fetchDisabledUsers(); break; case 'deleted': $users = $this->users->fetchDeletedUsers(); break; case 'all': default: $users = $this->users->fetchAllUsers(); break; } } } We fetch the console request, read parameters, and load users from our (theoretical) users service. In order to make this method functional, we'll have to display the result in the console window. Sending Output to the Console The simplest way for our controller to display data in the console window is to return a string. Let's modify our example to output a list of users: public function showUsersAction() { $request = $this->getRequest(); // Check verbose flag $verbose = $request->getParam('verbose') || $request->getParam('v'); // Check mode $mode = $request->getParam('mode', 'all'); // defaults to 'all' $users = []; switch ($mode) { case 'disabled': $users = $this->users->fetchDisabledUsers(); break; case 'deleted': $users = $this->users->fetchDeletedUsers(); break; case 'all': default: $users = $this->users->fetchAllUsers(); break; } if (count($users) === 0) { // Show an error message in the console return \"There are no users in the database\\n\"; } $result = ''; foreach ($users as $user) { $result .= $user->name . ' ' . $user->email . \"\\n\"; } return $result; // show it in the console } In the second conditional, we are checking if the users service found any users; if not, we return an error message to display immediately, terminating the application. If any users are found, we loop through each to prepare a listing, which we then return from the action for display in the console. Are we in a Console? Sometimes we might need to check if our method is being called from a console or from a web request. This is useful to block certain methods from running in the console or to change their behavior based on that context. Here is an example of how to check if we are dealing with a console request: namespace Application\\Controller; use Zend\\Mvc\\Controller\\AbstractActionController; use Zend\\View\\Model\\ViewModel; use Zend\\Console\\Request as ConsoleRequest; use RuntimeException; class IndexController extends AbstractActionController { public function showUsersAction() { $request = $this->getRequest(); // Make sure that we are running in a console and the user has not tricked our // application into running this action from a public web server. if (! $request instanceof ConsoleRequest) { throw new RuntimeException( 'You can only use this action from a console!' ); } /* ... */ } } Use Routing to protect Methods You do not need to secure all your controllers and methods from console requests. Controller actions will only be invoked when at least one console route matches it. HTTP and Console routes are separated and defined in different places in module (and application) configuration. There is no way to invoke a console action unless there is at least one route pointing to it. Similarly, there is no way for an HTTP action to be invoked unless there is at least one HTTP route that points to it. The example below shows how a single controller method can handle both Console and HTTP requests : namespace Application\\Controller; use Zend\\Mvc\\Controller\\AbstractActionController; use Zend\\View\\Model\\ViewModel; use Zend\\Console\\Request as ConsoleRequest; use Zend\\Http\\Request as HttpRequest; use RuntimeException; class IndexController extends AbstractActionController { public function showUsersAction() { $request = $this->getRequest(); $users = []; /* ... fetch users from database ... */ if ($request instanceof HttpRequest) { // display a web page with users list return new ViewModel($result); } if ($request instanceof ConsoleRequest) { // ... prepare console output and return it ... return $result; } throw new RuntimeException( 'Cannot handle request of type ' . get_class($request) ); } } AbstractConsoleController The best way to ensure you always receive a console request instance is to extend Zend\\Mvc\\Controller\\AbstractConsoleController . This controller instance also exposes a new method, getConsole() , providing you access to the console adapter, allowing you to use prompts, send output (including colorized output), and more. Reading Values from Console Parameters There are several types of parameters recognized by the Console component, all of which are described in the console routing chapter . Here, we'll focus on how to retrieve values from distinct parameters and flags. Positional Parameters After a route matches, we can access both literal parameters and value parameters via the $request instance, using the getParam() method. Assuming we have the following route: 'show-users' => [ 'options' => [ 'route' => 'show (all|deleted|locked|admin) [<groupName>]', 'defaults' => [ 'controller' => 'Application\\Controller\\Users', 'action' => 'showusers', ], ], ], If this route matches, our action can now query parameters in the following way: // an action inside Application\\Controller\\UsersController: public function showUsersAction() { $request = $this->getRequest(); // We can access named value parameters directly by their name: $showUsersFromGroup = $request->getParam('groupName'); // Literal parameters can be checked with isset() against their exact spelling if (isset($request->getParam('all'))) { // show all users } elseif (isset($request->getParam('deleted'))) { // show deleted users } /* ... */ } In case of parameter alternatives, it is a good idea to assign a name to the group , which simplifies the branching in our action controllers. We can do this with the following syntax: // inside of config.console.router.routes: 'show-users' => [ 'options' => [ 'route' => 'show (all|deleted|locked|admin):userTypeFilter [<groupName>]', 'defaults' => [ 'controller' => 'Application\\Controller\\Users', 'action' => 'showusers', ], ], ] Now we can use a the group name userTypeFilter to check which option has been selected by the user: public function showUsersAction() { $request = $this->getRequest(); // We can access named value parameters directly by their name: $showUsersFromGroup = $request->getParam('groupName'); // The selected option from second parameter is now stored under 'userTypeFilter' $userTypeFilter = $request->getParam('userTypeFilter'); switch ($userTypeFilter) { case 'all': // all users case 'deleted': // deleted users case 'locked': // ... // ... } } Flags Flags are directly accessible by name. Value-capturing flags will contain string values, as provided by the user. Non-value flags will be equal to true , or null if not present. Given the following route: 'find-user' => [ 'options' => [ 'route' => 'find user [--fast] [--verbose] [--id=] [--firstName=] [--lastName=] [--email=]', 'defaults' => [ 'controller' => 'Application\\Controller\\Users', 'action' => 'find', ], ], ], We can retrieve values in the following fashion: public function findAction() { $request = $this->getRequest(); // We can retrieve values from value flags using their name $searchId = $request->getParam('id', null); // default null $searchFirstName = $request->getParam('firstName', null); $searchLastName = $request->getParam('lastName', null); $searchEmail = $request->getParam('email', null); // Standard flags that have been matched will be equal to TRUE $isFast = (bool)$request->getParam('fast', false); // default false $isVerbose = (bool)$request->getParam('verbose', false); if ($isFast) { // perform a fast query ... } else { // perform standard query ... } } In case of flag alternatives , we have to check each alternative separately: /* * Assuming our route now reads: * 'route' => 'find user [--fast|-f] [--verbose|-v] ... ', */ public function findAction() { $request = $this->getRequest(); // Check both alternatives $isFast = $request->getParam('fast', false) || $request->getParam('f', false); $isVerbose = $request->getParam('verbose', false) || $request->getParam('v', false); // ... }","title":"Controllers"},{"location":"controllers/#controllers","text":"When using the zend-mvc integration with zend-console, a matched route results in dispatch of an action controller. In this chapter we will learn how ZF2 Controllers can interact with and return output to console window.","title":"Controllers"},{"location":"controllers/#abstractconsolecontroller","text":"zend-mvc-console provides a controller implementation for use with zend-mvc , Zend\\Mvc\\Controller\\AbstractConsoleController . The implementation extends from the zend-mvc AbstractActionController , and provides the following functionality: The method setConsole(Zend\\Console\\Adapter\\AdapterInterface $console) allows injecting a console adapter representing the current console environment. By default, the ControllerManager will inject this for you as part of controller instantiation. The method getConsole() allows you to retrieve the current console adapter instance, allowing you to retrieve console capabilities and generate console output. The dispatch() method will throw an exception if invoked in a non-console environment, ensuring that you do not need to do any checks within your action methods for the environment.","title":"AbstractConsoleController"},{"location":"controllers/#handling-console-requests","text":"Console requests are very similar to HTTP requests. In fact, they implement a common interface and are created at the same time in the MVC workflow. Console routes match against command line arguments and provide a defaults array, which holds the controller and action keys. These correspond with controller aliases in the ServiceManager , and method names in the controller class. This is analogous to the way HTTP requests are handled under zend-mvc. In this example we'll use the following route: // in file module/Application/config/module.config.php: return [ 'router' => [ 'routes' => [ // HTTP routes are here ], ], 'console' => [ 'router' => [ 'routes' => [ 'list-users' => [ 'options' => [ 'route' => 'show [all|disabled|deleted]:mode users [--verbose|-v]', 'defaults' => [ 'controller' => Application\\Controller\\Index::class, 'action' => 'show-users', ], ], ], ], ], ], /* ... */ ]; This route will match commands such as: $ php public/index.php show users $ php public/index.php show all users $ php public/index.php show disabled users This route maps to the method Application\\Controller\\IndexController::showUsersAction() . Let's add that method to our controller. namespace Application\\Controller; use Application\\Model\\Users; use Zend\\Mvc\\Controller\\AbstractActionController; use Zend\\View\\Model\\ViewModel; class IndexController extends AbstractActionController { private $users; public function __construct(Users $users) { $this->users = $users; } public function indexAction() { return new ViewModel(); // display standard index page } public function showUsersAction() { $request = $this->getRequest(); // Check verbose flag $verbose = $request->getParam('verbose') || $request->getParam('v'); // Check mode $mode = $request->getParam('mode', 'all'); // defaults to 'all' $users = []; switch ($mode) { case 'disabled': $users = $this->users->fetchDisabledUsers(); break; case 'deleted': $users = $this->users->fetchDeletedUsers(); break; case 'all': default: $users = $this->users->fetchAllUsers(); break; } } } We fetch the console request, read parameters, and load users from our (theoretical) users service. In order to make this method functional, we'll have to display the result in the console window.","title":"Handling Console Requests"},{"location":"controllers/#sending-output-to-the-console","text":"The simplest way for our controller to display data in the console window is to return a string. Let's modify our example to output a list of users: public function showUsersAction() { $request = $this->getRequest(); // Check verbose flag $verbose = $request->getParam('verbose') || $request->getParam('v'); // Check mode $mode = $request->getParam('mode', 'all'); // defaults to 'all' $users = []; switch ($mode) { case 'disabled': $users = $this->users->fetchDisabledUsers(); break; case 'deleted': $users = $this->users->fetchDeletedUsers(); break; case 'all': default: $users = $this->users->fetchAllUsers(); break; } if (count($users) === 0) { // Show an error message in the console return \"There are no users in the database\\n\"; } $result = ''; foreach ($users as $user) { $result .= $user->name . ' ' . $user->email . \"\\n\"; } return $result; // show it in the console } In the second conditional, we are checking if the users service found any users; if not, we return an error message to display immediately, terminating the application. If any users are found, we loop through each to prepare a listing, which we then return from the action for display in the console.","title":"Sending Output to the Console"},{"location":"controllers/#are-we-in-a-console","text":"Sometimes we might need to check if our method is being called from a console or from a web request. This is useful to block certain methods from running in the console or to change their behavior based on that context. Here is an example of how to check if we are dealing with a console request: namespace Application\\Controller; use Zend\\Mvc\\Controller\\AbstractActionController; use Zend\\View\\Model\\ViewModel; use Zend\\Console\\Request as ConsoleRequest; use RuntimeException; class IndexController extends AbstractActionController { public function showUsersAction() { $request = $this->getRequest(); // Make sure that we are running in a console and the user has not tricked our // application into running this action from a public web server. if (! $request instanceof ConsoleRequest) { throw new RuntimeException( 'You can only use this action from a console!' ); } /* ... */ } }","title":"Are we in a Console?"},{"location":"controllers/#reading-values-from-console-parameters","text":"There are several types of parameters recognized by the Console component, all of which are described in the console routing chapter . Here, we'll focus on how to retrieve values from distinct parameters and flags.","title":"Reading Values from Console Parameters"},{"location":"intro/","text":"Introduction Zend Framework 2 introduced the ability to write console applications via its MVC layer. This ability integrates a number of components, including: zend-console zend-eventmanager zend-modulemanager zend-servicemanager zend-stdlib zend-text zend-view When correctly configured, the functionality allows you to execute console applications via the same public/index.php script as used for HTTP requests: $ php public/index.php <arguments...>","title":"Introduction"},{"location":"intro/#introduction","text":"Zend Framework 2 introduced the ability to write console applications via its MVC layer. This ability integrates a number of components, including: zend-console zend-eventmanager zend-modulemanager zend-servicemanager zend-stdlib zend-text zend-view When correctly configured, the functionality allows you to execute console applications via the same public/index.php script as used for HTTP requests: $ php public/index.php <arguments...>","title":"Introduction"},{"location":"listeners/","text":"Listeners zend-mvc-console registers a number of listeners with zend-mvc applications. Below is a list of events, and the listeners zend-mvc-console registers. MvcEvent::EVENT_BOOTSTRAP (\"bootstrap\") Listeners The following classes listen to this event (sorted from higher priority to lower priority): Class Priority Method Called Triggers Description Zend\\Mvc\\Console\\View\\ViewManager 10000 onBootstrap none Prepares the view layer. Triggered By This event is triggered by the following classes: Class In Method Zend\\Mvc\\Application bootstrap MvcEvent::EVENT_DISPATCH (\"dispatch\") Listeners The following classes listen to this event (sorted from higher priority to lower priority): Class Priority Method Called Description Zend\\Mvc\\Console\\View\\InjectNamedConsoleParamsListener 1000 injectNamedParams Merge all params (route match params and params in the command), and add them to the Request object. Zend\\Mvc\\Console\\View\\CreateViewModelListener -80 createViewModelFromArray If the controller action returns an associative array, this listener casts it to a Zend\\Mvc\\Console\\View\\ViewModel object. Zend\\Mvc\\Console\\View\\CreateViewModelListener -80 createViewModelFromString If the controller action returns a string, this listener casts it to a Zend\\Mvc\\Console\\View\\ViewModel object. Zend\\Mvc\\Console\\View\\CreateViewModelListener -80 createViewModelFromNull If the controller action returns null, this listener casts it to a Zend\\Mvc\\Console\\View\\ViewModel object. Zend\\Mvc\\Console\\View\\InjectViewModelListener -100 injectViewModel Inserts the ViewModel (in this case, a Zend\\Mvc\\Console\\View\\ViewModel ) and adds it to the MvcEvent object. It either (a) adds it as a child to the default, composed view model, or (b) replaces it if the result is marked as terminal. Triggered By This event is triggered by the following classes: Class In Method Description Zend\\Mvc\\Application run Uses a short circuit callback to halt propagation of the event if an error is raised during routing. Zend\\Mvc\\Controller\\AbstractController dispatch If a listener returns a Response object, it halts propagation. Note: every AbstractController listens to this event and executes the onDispatch method when it is triggered. MvcEvent::EVENT_DISPATCH_ERROR (\"dispatch.error\") Listeners The following classes listen to this event (sorted from higher priority to lower priority): Class Priority Method Called Description Zend\\Mvc\\Console\\View\\RouteNotFoundStrategy 1 handleRouteNotFoundError Detect if an error is a \"route not found\" condition, and display a usage message. Zend\\Mvc\\Console\\View\\ExceptionStrategy 1 prepareExceptionViewModel Create an exception view model. Zend\\Mvc\\Console\\View\\InjectViewModelListener -100 injectViewModel Inserts the ViewModel (in this case, a Zend\\Mvc\\Console\\View\\ViewModel ) and adds it to the MvcEvent object. It either (a) adds it as a child to the default, composed view model, or (b) replaces it if the result is marked as terminable. Triggered By Class In Method Zend\\Mvc\\MiddlewareListener onDispatch Zend\\Mvc\\DispatchListener onDispatch Zend\\Mvc\\DispatchListener marshallControllerNotFoundEvent Zend\\Mvc\\DispatchListener marshallBadControllerEvent MvcEvent::EVENT_RENDER (\"render\") Listeners The following classes listen to this event (sorted from higher priority to lower priority): Class Priority Method Called Description Zend\\Mvc\\Console\\View\\DefaultRenderingStrategy -10000 render Render the view. Triggered By This event is triggered by the following classes: Class In Method Description Zend\\Mvc\\Application completeRequest This event is triggered just before the MvcEvent::FINISH event. MvcEvent::EVENT_RENDER_ERROR (\"render.error\") Listeners The following classes listen to this event (sorted from higher priority to lower priority): Console Context only The following listeners are only attached in a console context: Class Priority Method Called Description Zend\\Mvc\\Console\\View\\ExceptionStrategy 1 prepareExceptionViewModel Create an exception view model. Zend\\Mvc\\Console\\View\\InjectViewModelListener -100 injectViewModel Inserts the ViewModel (in this case, a Zend\\Mvc\\Console\\View\\ViewModel ) and adds it to the MvcEvent object. It either (a) adds it as a child to the default, composed view model, or (b) replaces it if the result is marked as terminable. Triggered By This event is triggered by the following classes: Class In Method Description Zend\\Mvc\\View\\Http\\DefaultRenderingStrategy render This event is triggered if an exception is raised during rendering. SendResponseEvent::EVENT_SEND_RESPONSE Listeners The following classes listen to this event (sorted from higher priority to lower priority): Class Priority Method Called Description Zend\\Mvc\\Console\\ResponseSender\\ConsoleResponseSender -2000 __invoke Emits console output. Triggered By This event is triggered by the following classes: Class In Method Description Zend\\Mvc\\SendResponseListener sendResponse Triggered by MvcEvent::FINISH at a priority of -10000, this listener emits the response to the client.","title":"Listeners"},{"location":"listeners/#listeners","text":"zend-mvc-console registers a number of listeners with zend-mvc applications. Below is a list of events, and the listeners zend-mvc-console registers.","title":"Listeners"},{"location":"listeners/#mvceventevent_bootstrap-bootstrap","text":"","title":"MvcEvent::EVENT_BOOTSTRAP (\"bootstrap\")"},{"location":"listeners/#mvceventevent_dispatch-dispatch","text":"","title":"MvcEvent::EVENT_DISPATCH (\"dispatch\")"},{"location":"listeners/#mvceventevent_dispatch_error-dispatcherror","text":"","title":"MvcEvent::EVENT_DISPATCH_ERROR (\"dispatch.error\")"},{"location":"listeners/#mvceventevent_render-render","text":"","title":"MvcEvent::EVENT_RENDER (\"render\")"},{"location":"listeners/#mvceventevent_render_error-rendererror","text":"","title":"MvcEvent::EVENT_RENDER_ERROR (\"render.error\")"},{"location":"listeners/#sendresponseeventevent_send_response","text":"","title":"SendResponseEvent::EVENT_SEND_RESPONSE"},{"location":"modules/","text":"Modules zend-mvc-console integrates zend-mvc with zend-console; the integration also works with modules loaded with the Module Manager . zend-mvc-console ships with a console-specific RouteNotFoundStrategy which is responsible for displaying console usage information when: the user has not provided any arguments; or arguments could not be matched by any routes. The strategy currently supports two types of information: application banners and usage information . Application Banner When using the console within a zend-mvc-console-enabled application, you can invoke it via the application bootstrap: $ php public/index.php By default, it will simply output the current ZF 2 version, like this: Our Application module (and any other module) can provide an application banner . In order to do so, our Module class has to implement Zend\\ModuleManager\\Feature\\ConsoleBannerProviderInterface . As an example: // module/Application/Module.php <?php namespace Application; use Zend\\ModuleManager\\Feature\\ConsoleBannerProviderInterface; use Zend\\Console\\Adapter\\AdapterInterface as Console; class Module implements ConsoleBannerProviderInterface { /** * This method is defined in ConsoleBannerProviderInterface */ public function getConsoleBanner(Console $console) { return 'MyModule 0.0.1'; } } Duck-typing allowed You can duck-type the interface implementation by implementing the getConsoleBanner() method without specifically implementing the ConsoleBannerProviderInterface . As you can see, the application banner should be a single line string that returns the module's name and (if available) its current version. If several modules define their own banner, they are displayed one after the other in the order in which the modules are loaded. This allows you to see at a glance which modules expose console commands. If we execute our console application now, we'll see the newly created banner: Let's create and load a second module that provides a banner: <?php // config/application.config.php return [ 'modules' => [ 'Application', 'User', // <- load user module in module/User ], // ... ]; The User module will provide info about itself: // module/User/Module.php <?php namespace User; use Zend\\ModuleManager\\Feature\\ConsoleBannerProviderInterface; use Zend\\Console\\Adapter\\AdapterInterface as Console; class Module implements ConsoleBannerProviderInterface { /** * This method is defined in ConsoleBannerProviderInterface */ public function getConsoleBanner(Console $console) { return \"User Module 0.0.1\"; } } Because the User module is loaded after the Application module, the result will look like this: Application Banner Display Application banners provided by modules are displayed as-is \u2014 no trimming or other adjustments will be performed on the text. As you can see, banners are also automatically colorized as blue. Usage Information In order to display usage information, our Module class must implement Zend\\ModuleManager\\Feature\\ConsoleUsageProviderInterface . Let's modify our example and add the new method defined in that interface: // module/Application/Module.php <?php namespace Application; use Zend\\ModuleManager\\Feature\\ConsoleBannerProviderInterface; use Zend\\ModuleManager\\Feature\\ConsoleUsageProviderInterface; use Zend\\Console\\Adapter\\AdapterInterface as Console; class Module implements ConsoleBannerProviderInterface, ConsoleUsageProviderInterface { public function getConsoleBanner(Console $console) { /* ... */ } /** * This method is defined in ConsoleUsageProviderInterface */ public function getConsoleUsage(Console $console) { return [ 'show stats' => 'Show application statistics', 'run cron' => 'Run automated jobs', '(enable|disable) debug' => 'Enable or disable debug mode for the application.', ]; } } Duck-typing allowed You can duck-type the interface implementation by implementing the getConsoleUsage() method without specifically implementing the ConsoleUsageProviderInterface . This will display the following information: Similar to application banners , multiple modules can provide usage information, which will be joined together and displayed to the user. The order in which usage information is displayed is the order in which modules are loaded. As you can see, the zend-mvc-console integration also prepends each module's usage with the module's name. This helps to visually separate commands by module \u2014 which is particularly useful when you have multiple modules providing commands. By default, the component colorizes the module names in red. Usage Information is arbitrary Usage info provided in modules is not connected with console routing . You can describe console usage in any form you prefer, and it does not affect how MVC handles console commands. In order to handle real console requests, you still need to define console routes. Free-form Text In order to output free-form text as usage information, getConsoleUsage() can return a string or an array of strings. As an example, the following is a single, free-form usage text: public function getConsoleUsage(Console $console) { return 'User module expects exactly one argument - user name. ' . 'It will display information for the provided user.'; } Usage Text is provided as-is The text provided is displayed as-is; no trimming or other adjustments will be performed. If you'd like to fit your usage information inside the console window, you could check its width with $console-getWidth() . List of Commands If getConsoleUsage() returns an associative array, it will be automatically aligned in 2 columns. The first column will be prepended with script name (the entry point for the application). This is useful to display the various commands exposed. public function getConsoleUsage(Console $console) { return [ 'delete user <userEmail>' => 'Delete user with email <userEmail>', 'disable user <userEmail>' => 'Disable user with email <userEmail>', 'list [all|disabled] users' => 'Show a list of users', 'find user [--email=] [--name=]' => 'Attempt to find a user by email or name', ]; } Command list Alignment Commands and their descriptions will be aligned in two columns that fit inside the terminal window. If the window is resized, text may wrap, but all content will be aligned. If you don't like the behavior, you can always return free-form text instead, as free-form text is never transformed or aligned. List of Parameters and Flags Returning an array of arrays from getConsoleUsage() will produce a listing of parameters. This is useful for explaining flags, switches, possible values and other information. The output will be aligned in multiple columns for readability. As an example: public function getConsoleUsage(Console $console) { return [ [ '<userEmail>', 'email of the user' ], [ '--verbose', 'Turn on verbose mode' ], [ '--quick', 'Perform a \"quick\" operation' ], [ '-v', 'Same as --verbose' ], [ '-w', 'Wide output'], ]; } This method can be used to display more than 2 columns of information: public function getConsoleUsage(Console $console) { return [ [ '<userEmail>', 'user email', 'Full email address of the user to find.' ], [ '--verbose', 'verbose mode', 'Display additional information during processing' ], [ '--quick', '\"quick\" operation', 'Do not check integrity, just make changes and finish' ], [ '-v', 'Same as --verbose', 'Display additional information during processing' ], [ '-w', 'wide output', 'When listing users, use the whole available screen width' ], ]; } Alignment All information will be aligned in one or more columns that fit inside the terminal window. If the window is resized, some text may wrap, but all content will remain aligned. In case the number of columns changes (e.g. the array contains different number of elements), a new table will be created, with its own alignment and column widths. If you don't like this behavior, you can always return free-form text . Mixing Styles You can use mix together all of the above styles to provide comprehensive usage information. public function getConsoleUsage(Console $console) { return [ 'Finding and listing users', 'list [all|disabled] users [-w]' => 'Show a list of users', 'find user [--email=] [--name=]' => 'Attempt to find a user by email or name', ['[all|disabled]', 'Display all users or only disabled accounts'], ['--email=EMAIL', 'Email of the user to find'], ['--name=NAME', 'Full name of the user to find.'], ['-w', 'Wide output - When listing users use the whole available screen width'], 'Manipulation of user database:', 'delete user <userEmail> [--verbose|-v] [--quick]' => 'Delete user with email <userEmail>', 'disable user <userEmail> [--verbose|-v]' => 'Disable user with email <userEmail>', [ '<userEmail>', 'user email', 'Full email address of the user to change.'], [ '--verbose', 'verbose mode', 'Display additional information during processing'], [ '--quick', '\"quick\" operation', 'Do not check integrity, just make changes and finish'], [ '-v', 'Same as --verbose', 'Display additional information during processing'], ]; } Best Practices Here are the best practices when providing usage for your commands: Your module's getConsoleBanner() method should return a one-line string containing the module's name and its version (if available); do not provide any other information. Your getConsoleUsage() method should not return the module's name, as it is prepended automatically for you by the zend-mvc-console integration.","title":"Modules"},{"location":"modules/#modules","text":"zend-mvc-console integrates zend-mvc with zend-console; the integration also works with modules loaded with the Module Manager . zend-mvc-console ships with a console-specific RouteNotFoundStrategy which is responsible for displaying console usage information when: the user has not provided any arguments; or arguments could not be matched by any routes. The strategy currently supports two types of information: application banners and usage information .","title":"Modules"},{"location":"modules/#application-banner","text":"When using the console within a zend-mvc-console-enabled application, you can invoke it via the application bootstrap: $ php public/index.php By default, it will simply output the current ZF 2 version, like this: Our Application module (and any other module) can provide an application banner . In order to do so, our Module class has to implement Zend\\ModuleManager\\Feature\\ConsoleBannerProviderInterface . As an example: // module/Application/Module.php <?php namespace Application; use Zend\\ModuleManager\\Feature\\ConsoleBannerProviderInterface; use Zend\\Console\\Adapter\\AdapterInterface as Console; class Module implements ConsoleBannerProviderInterface { /** * This method is defined in ConsoleBannerProviderInterface */ public function getConsoleBanner(Console $console) { return 'MyModule 0.0.1'; } }","title":"Application Banner"},{"location":"modules/#usage-information","text":"In order to display usage information, our Module class must implement Zend\\ModuleManager\\Feature\\ConsoleUsageProviderInterface . Let's modify our example and add the new method defined in that interface: // module/Application/Module.php <?php namespace Application; use Zend\\ModuleManager\\Feature\\ConsoleBannerProviderInterface; use Zend\\ModuleManager\\Feature\\ConsoleUsageProviderInterface; use Zend\\Console\\Adapter\\AdapterInterface as Console; class Module implements ConsoleBannerProviderInterface, ConsoleUsageProviderInterface { public function getConsoleBanner(Console $console) { /* ... */ } /** * This method is defined in ConsoleUsageProviderInterface */ public function getConsoleUsage(Console $console) { return [ 'show stats' => 'Show application statistics', 'run cron' => 'Run automated jobs', '(enable|disable) debug' => 'Enable or disable debug mode for the application.', ]; } }","title":"Usage Information"},{"location":"modules/#best-practices","text":"Here are the best practices when providing usage for your commands: Your module's getConsoleBanner() method should return a one-line string containing the module's name and its version (if available); do not provide any other information. Your getConsoleUsage() method should not return the module's name, as it is prepended automatically for you by the zend-mvc-console integration.","title":"Best Practices"},{"location":"routing/","text":"Routing zend-mvc-console integrates zend-router with zend-console, routing command line arguments to the appropriate action controller and action method that will handle the request. Actions can perform any number of tasks prior to returning a result to display in the console window. When using zend-mvc-console, console routes are provided via configuration. // The following can sit inside of module/Application/config/module.config.php, // any other module's configuration, or within files under config/autoload/: return [ 'router' => [ 'routes' => [ // HTTP routes are here ], ], 'console' => [ 'router' => [ 'routes' => [ // Console routes go here ], ], ], ]; Console routes exposed via zend-mvc-console will only be processed when the application is run inside a console (terminal) window; they are not used for web (HTTP) requests. It is possible to define only HTTP routes (web application only), only console routes (console-only application), or a mixture of the two. As an example of a single route: // inside config.console.router.routes: 'my-first-route' => [ 'type' => 'simple', // This is the default, and may be omitted; more on // types below 'options' => [ 'route' => 'foo bar', 'defaults' => [ 'controller' => Application\\Controller\\Index::class, 'action' => 'password', ], ], ], We have created a simple console route with the name my-first-route . It expects two parameters: foo and bar . If user puts these in a console, Application\\Controller\\IndexController::passwordAction() action will be invoked. Route Types In the last example of the previous section, we noted that configuration for a given route can accept a type argument. This refers to the route type (which maps to a class) to use when creating the route instance. zend-mvc-console defines several types. Simple Route Zend\\Mvc\\Console\\Router\\Simple is a factory for zend-console's DefaultRouteMatcher , and decorates it to work with the zend-mvc routing system. See the section on the default route matcher for details on route strings and available configuration to provide. Catchall Route This special route will catch all console requests, regardless of the parameters provided. 'default-route' => [ 'type' => 'catchall', 'options' => [ 'route' => '', 'defaults' => [ 'controller' => 'Application\\Controller\\Index', 'action' => 'consoledefault', ], ], ], This route type is rarely used; one possible use case is to register it as the last console route, in order to display usage information. Before you do so, read about the preferred way of displaying console usage information ; following recommendations will guarantee proper interoperation with other modules in your application.","title":"Routing"},{"location":"routing/#routing","text":"zend-mvc-console integrates zend-router with zend-console, routing command line arguments to the appropriate action controller and action method that will handle the request. Actions can perform any number of tasks prior to returning a result to display in the console window. When using zend-mvc-console, console routes are provided via configuration. // The following can sit inside of module/Application/config/module.config.php, // any other module's configuration, or within files under config/autoload/: return [ 'router' => [ 'routes' => [ // HTTP routes are here ], ], 'console' => [ 'router' => [ 'routes' => [ // Console routes go here ], ], ], ]; Console routes exposed via zend-mvc-console will only be processed when the application is run inside a console (terminal) window; they are not used for web (HTTP) requests. It is possible to define only HTTP routes (web application only), only console routes (console-only application), or a mixture of the two. As an example of a single route: // inside config.console.router.routes: 'my-first-route' => [ 'type' => 'simple', // This is the default, and may be omitted; more on // types below 'options' => [ 'route' => 'foo bar', 'defaults' => [ 'controller' => Application\\Controller\\Index::class, 'action' => 'password', ], ], ], We have created a simple console route with the name my-first-route . It expects two parameters: foo and bar . If user puts these in a console, Application\\Controller\\IndexController::passwordAction() action will be invoked.","title":"Routing"},{"location":"routing/#route-types","text":"In the last example of the previous section, we noted that configuration for a given route can accept a type argument. This refers to the route type (which maps to a class) to use when creating the route instance. zend-mvc-console defines several types.","title":"Route Types"},{"location":"services/","text":"Default Services zend-mvc-console exists to enable legacy console tooling for zend-mvc applications. As such, one of its primary functions is providing services to the MVC layer. This chapter details the various services registered by zend-mvc-console by default, the classes they represent, and any configuration options available. Services provided The following is a list of service names and what the service returns. Service Name Creates instance of ConsoleAdapter Zend\\Console\\Adapter\\AdapterInterface ConsoleExceptionStrategy Zend\\Mvc\\Console\\View\\ExceptionStrategy ConsoleRouteNotFoundStrategy Zend\\Mvc\\Console\\View\\RouteNotFoundStrategy ConsoleRouter Zend\\Mvc\\Console\\Router\\SimpleRouteStack ConsoleViewManager Zend\\Mvc\\Console\\View\\ViewManager Zend\\Mvc\\Console\\View\\DefaultRenderingStrategy Zend\\Mvc\\Console\\View\\DefaultRenderingStrategy Zend\\Mvc\\Console\\View\\Renderer Zend\\Mvc\\Console\\View\\Renderer Aliases The following is a list of service aliases. Alias Aliased to ConsoleDefaultRenderingStrategy Zend\\Mvc\\Console\\View\\DefaultRenderingStrategy ConsoleRenderer Zend\\Mvc\\Console\\View\\Renderer Delegator Factories When operating in a console environment, several typical zend-mvc services need to operate differently, or require alternate services. To enable that, zend-mvc-console provides a number of delegator factories . The following is a list of those provided, the service they override, and a description of what they do. Service Name Delegator Factory Description Application Zend\\Mvc\\Console\\Service\\ConsoleApplicationDelegatorFactory In a console environment, attaches the Zend\\Mvc\\Console\\View\\ViewManager to the application instance before returning it. ControllerManager Zend\\Mvc\\Console\\Service\\ControllerManagerDelegatorFactory Attaches an initializer for injecting AbstractConsoleController instances with a console adapter. ControllerPluginManager Zend\\Mvc\\Console\\Service\\ControllerPluginManagerDelegatorFactory Injects the CreateConsoleNotFoundModel plugin into the controller PluginManager . Request Zend\\Mvc\\Console\\Service\\ConsoleRequestDelegatorFactory If a console environment is detected, replaces the request with a Zend\\Console\\Request . Response Zend\\Mvc\\Console\\Service\\ConsoleResponseDelegatorFactory If a console environment is detected, replaces the response with a Zend\\Console\\Response . Router Zend\\Mvc\\Console\\Router\\ConsoleRouterDelegatorFactory If a console environment is detected, replaces the router with the ConsoleRouter service. Zend\\Mvc\\SendResponseListener Zend\\Mvc\\Console\\Service\\ConsoleResponseSenderDelegatorFactory If a console environment is detected, attaches the Zend\\Mvc\\Console\\ResponseSender\\ConsoleResponseSender to the SendResponseListener . ViewHelperManager Zend\\Mvc\\Console\\Service\\ConsoleViewHelperManagerDelegatorFactory If a console environment is detected, injects override factories for the url and basePath view helpers into the HelperPluginManager . Application Configuration Options Console tooling provides several locations for configuration, primarily at the service, routing, and view levels. Services All services registered can be configured to use different factories; see the above tables for details on what service names to override. Routing Routing configuration is detailed in the routing chapter . ViewManager Zend\\Mvc\\Console\\View\\ViewManager acts similarly to its zend-mvc equivalent , and will look for one or the other of the following configuration structures: return [ 'view_manager' => [ 'mvc_strategies' => $stringOrArrayOfMvcListenerServiceNames, 'strategies' => $stringOrArrayOfViewListenerServiceNames, ], 'console' => [ 'view_manager' => [ 'mvc_strategies' => $stringOrArrayOfMvcListenerServiceNames, 'strategies' => $stringOrArrayOfViewListenerServiceNames, ], ], ]; Preference is given to those under the console top-level key (those under view_manager are ignored if the console.view_manager structure exists). mvc_strategies refers to view-related listeners that need to operate on the Zend\\Mvc\\MvcEvent context. strategies refers to view-related listeners that operate on the Zend\\View\\ViewEvent context.","title":"Default Services"},{"location":"services/#default-services","text":"zend-mvc-console exists to enable legacy console tooling for zend-mvc applications. As such, one of its primary functions is providing services to the MVC layer. This chapter details the various services registered by zend-mvc-console by default, the classes they represent, and any configuration options available.","title":"Default Services"},{"location":"services/#services-provided","text":"The following is a list of service names and what the service returns. Service Name Creates instance of ConsoleAdapter Zend\\Console\\Adapter\\AdapterInterface ConsoleExceptionStrategy Zend\\Mvc\\Console\\View\\ExceptionStrategy ConsoleRouteNotFoundStrategy Zend\\Mvc\\Console\\View\\RouteNotFoundStrategy ConsoleRouter Zend\\Mvc\\Console\\Router\\SimpleRouteStack ConsoleViewManager Zend\\Mvc\\Console\\View\\ViewManager Zend\\Mvc\\Console\\View\\DefaultRenderingStrategy Zend\\Mvc\\Console\\View\\DefaultRenderingStrategy Zend\\Mvc\\Console\\View\\Renderer Zend\\Mvc\\Console\\View\\Renderer","title":"Services provided"},{"location":"services/#aliases","text":"The following is a list of service aliases. Alias Aliased to ConsoleDefaultRenderingStrategy Zend\\Mvc\\Console\\View\\DefaultRenderingStrategy ConsoleRenderer Zend\\Mvc\\Console\\View\\Renderer","title":"Aliases"},{"location":"services/#delegator-factories","text":"When operating in a console environment, several typical zend-mvc services need to operate differently, or require alternate services. To enable that, zend-mvc-console provides a number of delegator factories . The following is a list of those provided, the service they override, and a description of what they do. Service Name Delegator Factory Description Application Zend\\Mvc\\Console\\Service\\ConsoleApplicationDelegatorFactory In a console environment, attaches the Zend\\Mvc\\Console\\View\\ViewManager to the application instance before returning it. ControllerManager Zend\\Mvc\\Console\\Service\\ControllerManagerDelegatorFactory Attaches an initializer for injecting AbstractConsoleController instances with a console adapter. ControllerPluginManager Zend\\Mvc\\Console\\Service\\ControllerPluginManagerDelegatorFactory Injects the CreateConsoleNotFoundModel plugin into the controller PluginManager . Request Zend\\Mvc\\Console\\Service\\ConsoleRequestDelegatorFactory If a console environment is detected, replaces the request with a Zend\\Console\\Request . Response Zend\\Mvc\\Console\\Service\\ConsoleResponseDelegatorFactory If a console environment is detected, replaces the response with a Zend\\Console\\Response . Router Zend\\Mvc\\Console\\Router\\ConsoleRouterDelegatorFactory If a console environment is detected, replaces the router with the ConsoleRouter service. Zend\\Mvc\\SendResponseListener Zend\\Mvc\\Console\\Service\\ConsoleResponseSenderDelegatorFactory If a console environment is detected, attaches the Zend\\Mvc\\Console\\ResponseSender\\ConsoleResponseSender to the SendResponseListener . ViewHelperManager Zend\\Mvc\\Console\\Service\\ConsoleViewHelperManagerDelegatorFactory If a console environment is detected, injects override factories for the url and basePath view helpers into the HelperPluginManager .","title":"Delegator Factories"},{"location":"services/#application-configuration-options","text":"Console tooling provides several locations for configuration, primarily at the service, routing, and view levels.","title":"Application Configuration Options"},{"location":"migration/v2-to-v3/","text":"Version 2 to Version 3 zend-mvc-console ports all console functionality from zend-mvc and zend-view v2 releases to a single component. As such, a number of classes were renamed that may impact end-users. zend-mvc Functionality AbstractConsoleController Zend\\Mvc\\Controller\\AbstractConsoleController becomes Zend\\Mvc\\Console\\Controller\\AbstractConsoleController . Otherwise, all functionality remains the same. Update your code to import the AbstractConsoleController under its new namespace. Routing The namespace Zend\\Mvc\\Router\\Console becomes Zend\\Mvc\\Console\\Router . All classes retain existing functionality. If you were using default routes ( Simple ) or using the short names to refer to console routes, no changes will be necessary. Otherwise, update your code to refer to the new namespace. ResponseSender Zend\\Mvc\\ResponseSender\\ConsoleResponseSender becomes Zend\\Mvc\\Console\\ResponseSender\\ConsoleResponseSender . As this is an implementation detail, it should have no impact on the end-user. Listeners The Zend\\Mvc\\View\\Console namespace becomes Zend\\Mvc\\Console\\View , but all existing listeners retain their names and functionality. As these were all managed by the console-specific ViewManager , this change should have no impact on the end-user unless: any of these classes were being extended any custom factories were being used to provide the services (specifically the ConsoleRouteNotFoundStrategy , ConsoleExceptionStrategy , and ConsoleDefaultRenderingStrategy ). In such cases, you will need to update your code to reference the new namespace. zend-view Functionality ViewModel zend-view provided a Zend\\View\\Model\\ConsoleModel class. This is now Zend\\Mvc\\Console\\View\\ViewModel . If you were returning ConsoleModel previously, update your code to return the new version. Renderer zend-view provided a Zend\\View\\Renderer\\ConsoleRenderer class. This is now Zend\\Mvc\\Console\\View\\Renderer . Additionally, the console-specific DefaultRenderingStrategy now consumes the renderer (it did not in version 2).","title":"Version 2 to Version 3"},{"location":"migration/v2-to-v3/#version-2-to-version-3","text":"zend-mvc-console ports all console functionality from zend-mvc and zend-view v2 releases to a single component. As such, a number of classes were renamed that may impact end-users.","title":"Version 2 to Version 3"},{"location":"migration/v2-to-v3/#zend-mvc-functionality","text":"","title":"zend-mvc Functionality"},{"location":"migration/v2-to-v3/#zend-view-functionality","text":"","title":"zend-view Functionality"}]}