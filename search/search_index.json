{
    "docs": [
        {
            "location": "/",
            "text": "zend-mvc-console\n\n\n\n\n\n\nzend-mvc-console provides integration between:\n\n\n\n\nzend-console\n\n\nzend-mvc\n\n\nzend-router\n\n\nzend-view\n\n\n\n\nand replaces the console functionality found in the v2 releases of the latter\nthree components.\n\n\n\n\nFile issues at https://github.com/zendframework/zend-mvc-console/issues\n\n\nDocumentation is at https://docs.zendframework.com/zend-mvc-console/\n\n\n\n\nInstallation\n\n\n$ composer require zendframework/zend-mvc-console\n\n\n\nAssuming you are using the \ncomponent\ninstaller\n, doing so\nwill enable the component in your application, allowing you to immediately start\ndeveloping console applications via your MVC. If you are not, please read the\n\nintroduction\n for\ndetails on how to register the functionality with your application.\n\n\nFor use with zend-mvc v3 and up\n\n\nWhile this component has an initial stable release, please do not use it with\nzend-mvc releases prior to v3, as it is not compatible.\n\n\nMigrating from zend-mvc v2 console to zend-mvc-console\n\n\nPlease see the \nmigration guide\n\nfor details on how to migrate your existing zend-mvc console functionality to\nthe features exposed by this component.",
            "title": "zend-mvc-console"
        },
        {
            "location": "/#zend-mvc-console",
            "text": "zend-mvc-console provides integration between:   zend-console  zend-mvc  zend-router  zend-view   and replaces the console functionality found in the v2 releases of the latter\nthree components.   File issues at https://github.com/zendframework/zend-mvc-console/issues  Documentation is at https://docs.zendframework.com/zend-mvc-console/",
            "title": "zend-mvc-console"
        },
        {
            "location": "/#installation",
            "text": "$ composer require zendframework/zend-mvc-console  Assuming you are using the  component\ninstaller , doing so\nwill enable the component in your application, allowing you to immediately start\ndeveloping console applications via your MVC. If you are not, please read the introduction  for\ndetails on how to register the functionality with your application.",
            "title": "Installation"
        },
        {
            "location": "/#for-use-with-zend-mvc-v3-and-up",
            "text": "While this component has an initial stable release, please do not use it with\nzend-mvc releases prior to v3, as it is not compatible.",
            "title": "For use with zend-mvc v3 and up"
        },
        {
            "location": "/#migrating-from-zend-mvc-v2-console-to-zend-mvc-console",
            "text": "Please see the  migration guide \nfor details on how to migrate your existing zend-mvc console functionality to\nthe features exposed by this component.",
            "title": "Migrating from zend-mvc v2 console to zend-mvc-console"
        },
        {
            "location": "/intro/",
            "text": "Introduction\n\n\nZend Framework 2 introduce the ability to write console applications via its MVC\nlayer. This ability integrates a number of components, including:\n\n\n\n\nzend-console\n\n\nzend-eventmanager\n\n\nzend-modulemanager\n\n\nzend-servicemanager\n\n\nzend-stdlib\n\n\nzend-text\n\n\nzend-view\n\n\n\n\nWhen correctly configured, the functionality allows you to execute console\napplications via the same \npublic/index.php\n script as used for HTTP requests:\n\n\n$ php public/index.php <arguments...>\n\n\n\nFor version 3 we have separated the functionality into a separate integration\ncomponent, zend-mvc-console. You can install and activate it via composer:\n\n\n$ composer require zendframework/zend-mvc-console\n\n\n\nAssuming you are using the \ncomponent\ninstaller\n, doing so\nwill enable the component in your application, allowing you to immediately start\ndeveloping console applications via your MVC.\n\n\n\n\nManual installation\n\n\nIf you are not using the component installer, you will need to add this\ncomponent as a module at the start of your module list in your Zend Framework\napplication.\n\n\nIf using a vanilla skeleton application, update \nconfig/application.config.php\n:\n\n\n'modules' => [\n    'Zend\\Mvc\\Console', // add it to the top of your module list\n    /* ... */\n]\n\n\n\nIf using Apigility, update your \nconfig/modules.config.php\n:\n\n\nreturn [\n    'Zend\\Mvc\\Console', // add it to the top of your module list\n    /* ... */\n];\n\n\n\n\n\nDeprecated\n\n\nDue to the amount of integration required to support console tooling via the\nMVC, and because \nbetter, more standalone solutions\nexist\n, we will not be maintaining\nzend-mvc-console long term. We strongly urge developers to start migrating their\nMVC-based console tooling to use other libraries, such as\n\nzf-console\n.\n\n\nMigration\n\n\nIn order to separate the console tooling from zend-mvc and provide it as a\nstandalone package, we needed to make a few changes. See the\n\nmigration guide\n for details.",
            "title": "Intro"
        },
        {
            "location": "/intro/#introduction",
            "text": "Zend Framework 2 introduce the ability to write console applications via its MVC\nlayer. This ability integrates a number of components, including:   zend-console  zend-eventmanager  zend-modulemanager  zend-servicemanager  zend-stdlib  zend-text  zend-view   When correctly configured, the functionality allows you to execute console\napplications via the same  public/index.php  script as used for HTTP requests:  $ php public/index.php <arguments...>  For version 3 we have separated the functionality into a separate integration\ncomponent, zend-mvc-console. You can install and activate it via composer:  $ composer require zendframework/zend-mvc-console  Assuming you are using the  component\ninstaller , doing so\nwill enable the component in your application, allowing you to immediately start\ndeveloping console applications via your MVC.",
            "title": "Introduction"
        },
        {
            "location": "/intro/#manual-installation",
            "text": "If you are not using the component installer, you will need to add this\ncomponent as a module at the start of your module list in your Zend Framework\napplication.  If using a vanilla skeleton application, update  config/application.config.php :  'modules' => [\n    'Zend\\Mvc\\Console', // add it to the top of your module list\n    /* ... */\n]  If using Apigility, update your  config/modules.config.php :  return [\n    'Zend\\Mvc\\Console', // add it to the top of your module list\n    /* ... */\n];",
            "title": "Manual installation"
        },
        {
            "location": "/intro/#deprecated",
            "text": "Due to the amount of integration required to support console tooling via the\nMVC, and because  better, more standalone solutions\nexist , we will not be maintaining\nzend-mvc-console long term. We strongly urge developers to start migrating their\nMVC-based console tooling to use other libraries, such as zf-console .",
            "title": "Deprecated"
        },
        {
            "location": "/intro/#migration",
            "text": "In order to separate the console tooling from zend-mvc and provide it as a\nstandalone package, we needed to make a few changes. See the migration guide  for details.",
            "title": "Migration"
        },
        {
            "location": "/routing/",
            "text": "Routing\n\n\nzend-mvc-console integrates zend-router with zend-console, routing command line\narguments to the appropriate action controller and action method that will\nhandle the request. Actions can perform any number of tasks prior to returning a\nresult to display in the console window.\n\n\nWhen using zend-mvc-console, console routes are provided via configuration.\n\n\n// The following can sit inside of module/Application/config/module.config.php,\n// any other module's configuration, or within files under config/autoload/:\nreturn [\n    'router' => [\n        'routes' => [\n            // HTTP routes are here\n        ],\n    ],\n\n    'console' => [\n        'router' => [\n            'routes' => [\n                // Console routes go here\n            ],\n        ],\n    ],\n];\n\n\n\nConsole routes exposed via zend-mvc-console will only be processed when the application\nis run inside a console (terminal) window; they are not used for web (HTTP)\nrequests. It is possible to define only HTTP routes (web application only), only\nconsole routes (console-only application), or a mixture of the two.\n\n\nAs an example of a single route:\n\n\n// inside config.console.router.routes:\n'my-first-route' => [\n    'type'    => 'simple',  // This is the default, and may be omitted; more on\n                            // types below\n    'options' => [\n        'route'    => 'foo bar',\n        'defaults' => [\n            'controller' => Application\\Controller\\Index::class,\n            'action'     => 'password',\n        ],\n    ],\n],\n\n\n\nWe have created a \nsimple\n console route with the name \nmy-first-route\n. It\nexpects two parameters: \nfoo\n and \nbar\n. If user puts these in a console,\n\nApplication\\Controller\\IndexController::passwordAction()\n action will be\ninvoked.\n\n\nRoute types\n\n\nIn the last example of the previous section, we noted that configuration for a\ngiven route can accept a \ntype\n argument. This refers to the route type (which\nmaps to a class) to use when creating the route instance. zend-mvc-console defines\nseveral types.\n\n\nSimple route\n\n\nZend\\Mvc\\Console\\Router\\Simple\n is a factory for zend-console's\n\nDefaultRouteMatcher\n, and decorates it to work with the zend-mvc routing\nsystem. See the section on \nthe default route matcher\n\nfor details on route strings and available configuration to provide.\n\n\nCatchall route\n\n\nThis special route will catch all console requests, regardless of the parameters provided.\n\n\n'default-route' => [\n    'type'     => 'catchall',\n    'options'  => [\n        'route'    => '',\n        'defaults' => [\n            'controller' => 'Application\\Controller\\Index',\n            'action'     => 'consoledefault',\n        ],\n    ],\n],\n\n\n\nThis route type is rarely used; one possible use case is to register it as the\nlast console route, in order to display usage information. Before you do so,\nread about the \npreferred way of displaying console usage information\n;\nfollowing recommendations will guarantee proper interoperation with other\nmodules in your application.",
            "title": "Routing"
        },
        {
            "location": "/routing/#routing",
            "text": "zend-mvc-console integrates zend-router with zend-console, routing command line\narguments to the appropriate action controller and action method that will\nhandle the request. Actions can perform any number of tasks prior to returning a\nresult to display in the console window.  When using zend-mvc-console, console routes are provided via configuration.  // The following can sit inside of module/Application/config/module.config.php,\n// any other module's configuration, or within files under config/autoload/:\nreturn [\n    'router' => [\n        'routes' => [\n            // HTTP routes are here\n        ],\n    ],\n\n    'console' => [\n        'router' => [\n            'routes' => [\n                // Console routes go here\n            ],\n        ],\n    ],\n];  Console routes exposed via zend-mvc-console will only be processed when the application\nis run inside a console (terminal) window; they are not used for web (HTTP)\nrequests. It is possible to define only HTTP routes (web application only), only\nconsole routes (console-only application), or a mixture of the two.  As an example of a single route:  // inside config.console.router.routes:\n'my-first-route' => [\n    'type'    => 'simple',  // This is the default, and may be omitted; more on\n                            // types below\n    'options' => [\n        'route'    => 'foo bar',\n        'defaults' => [\n            'controller' => Application\\Controller\\Index::class,\n            'action'     => 'password',\n        ],\n    ],\n],  We have created a  simple  console route with the name  my-first-route . It\nexpects two parameters:  foo  and  bar . If user puts these in a console, Application\\Controller\\IndexController::passwordAction()  action will be\ninvoked.",
            "title": "Routing"
        },
        {
            "location": "/routing/#route-types",
            "text": "In the last example of the previous section, we noted that configuration for a\ngiven route can accept a  type  argument. This refers to the route type (which\nmaps to a class) to use when creating the route instance. zend-mvc-console defines\nseveral types.",
            "title": "Route types"
        },
        {
            "location": "/routing/#simple-route",
            "text": "Zend\\Mvc\\Console\\Router\\Simple  is a factory for zend-console's DefaultRouteMatcher , and decorates it to work with the zend-mvc routing\nsystem. See the section on  the default route matcher \nfor details on route strings and available configuration to provide.",
            "title": "Simple route"
        },
        {
            "location": "/routing/#catchall-route",
            "text": "This special route will catch all console requests, regardless of the parameters provided.  'default-route' => [\n    'type'     => 'catchall',\n    'options'  => [\n        'route'    => '',\n        'defaults' => [\n            'controller' => 'Application\\Controller\\Index',\n            'action'     => 'consoledefault',\n        ],\n    ],\n],  This route type is rarely used; one possible use case is to register it as the\nlast console route, in order to display usage information. Before you do so,\nread about the  preferred way of displaying console usage information ;\nfollowing recommendations will guarantee proper interoperation with other\nmodules in your application.",
            "title": "Catchall route"
        },
        {
            "location": "/controllers/",
            "text": "Console Controllers\n\n\nWhen using the zend-mvc integration with zend-console, a matched route results\nin dispatch of an action controller. In this chapter we will learn how ZF2\nControllers can interact with and return output to console window.\n\n\nAbstractConsoleController\n\n\nzend-mvc-console provides a controller implementation for use with\n\nzend-mvc\n,\n\nZend\\Mvc\\Controller\\AbstractConsoleController\n. The implementation\nextends from the zend-mvc \nAbstractActionController\n,\nand provides the following functionality:\n\n\n\n\nThe method \nsetConsole(Zend\\Console\\Adapter\\AdapterInterface $console)\n allows\n  injecting a console adapter representing the current console environment. By\n  default, the \nControllerManager\n will inject this for you as part of\n  controller instantiation.\n\n\nThe method \ngetConsole()\n allows you to retrieve the current console adapter\n  instance, allowing you to retrieve console capabilities and generate console\n  output.\n\n\nThe \ndispatch()\n method will throw an exception if invoked in a non-console\n  environment, ensuring that you do not need to do any checks within your action\n  methods for the environment.\n\n\n\n\nInterfaces and Collaborators\n\n\nAbstractRestfulController\n implements each of the following interfaces:\n\n\n\n\nZend\\Stdlib\\DispatchableInterface\n\n\nZend\\Mvc\\InjectApplicationEventInterface\n\n\nZend\\EventManager\\EventManagerAwareInterface\n\n\n\n\nThe composed \nEventManager\n will be configured to listen on the following contexts:\n\n\n\n\nZend\\Stdlib\\DispatchableInterface\n\n\nZend\\Mvc\\Controller\\AbstractConsoleController\n\n\nZend\\Mvc\\Controller\\AbstractActionController\n\n\nZend\\Mvc\\Controller\\AbstractController\n\n\n\n\nAdditionally, if you extend the class, it will listen on the name of the\nextending class.\n\n\nHandling console requests\n\n\nConsole requests are very similar to HTTP requests. In fact, they implement a\ncommon interface and are created at the same time in the MVC workflow. \nConsole routes\n\nmatch against command line arguments and provide a \ndefaults\n array, which holds\nthe \ncontroller\n and \naction\n keys. These correspond with controller aliases in\nthe \nServiceManager\n, and method names in the controller class. This is\nanalogous to the way HTTP requests are handled under zend-mvc.\n\n\nIn this example we'll use the following route:\n\n\n// in file module/Application/config/module.config.php:\nreturn [\n    'router'  => [\n        'routes' => [\n            // HTTP routes are here\n        ],\n    ],\n    'console' => [\n        'router' => [\n            'routes' => [\n                'list-users' => [\n                    'options' => [\n                        'route'    => 'show [all|disabled|deleted]:mode users [--verbose|-v]',\n                        'defaults' => [\n                            'controller' => Application\\Controller\\Index::class,\n                            'action'     => 'show-users',\n                        ],\n                    ],\n                ],\n            ],\n        ],\n    ],\n    /* ... */\n];\n\n\n\nThis route will match commands such as:\n\n\n$ php public/index.php show users\n$ php public/index.php show all users\n$ php public/index.php show disabled users\n\n\n\nThis route maps to the method \nApplication\\Controller\\IndexController::showUsersAction()\n.\n\n\nLet's add that method to our controller.\n\n\nnamespace Application\\Controller;\n\nuse Application\\Model\\Users;\nuse Zend\\Mvc\\Controller\\AbstractActionController;\nuse Zend\\View\\Model\\ViewModel;\n\nclass IndexController extends AbstractActionController\n{\n    private $users;\n\n    public function __construct(Users $users)\n    {\n        $this->users = $users;\n    }\n\n    public function indexAction()\n    {\n        return new ViewModel(); // display standard index page\n    }\n\n    public function showUsersAction()\n    {\n        $request = $this->getRequest();\n\n        // Check verbose flag\n        $verbose = $request->getParam('verbose') || $request->getParam('v');\n\n        // Check mode\n        $mode = $request->getParam('mode', 'all'); // defaults to 'all'\n\n        $users = [];\n        switch ($mode) {\n            case 'disabled':\n                $users = $this->users->fetchDisabledUsers();\n                break;\n\n            case 'deleted':\n                $users = $this->users->fetchDeletedUsers();\n                break;\n\n            case 'all':\n\n            default:\n                $users = $this->users->fetchAllUsers();\n                break;\n        }\n    }\n}\n\n\n\nWe fetch the console request, read parameters, and load users from our\n(theoretical) users service.  In order to make this method functional, we'll\nhave to display the result in the console window.\n\n\nSending output to the console\n\n\nThe simplest way for our controller to display data in the console window is to\nreturn a string. Let's modify our example to output a list of users:\n\n\npublic function showUsersAction()\n{\n    $request = $this->getRequest();\n\n    // Check verbose flag\n    $verbose = $request->getParam('verbose') || $request->getParam('v');\n\n    // Check mode\n    $mode = $request->getParam('mode', 'all'); // defaults to 'all'\n\n    $users = [];\n    switch ($mode) {\n        case 'disabled':\n            $users = $this->users->fetchDisabledUsers();\n            break;\n\n        case 'deleted':\n            $users = $this->users->fetchDeletedUsers();\n            break;\n\n        case 'all':\n\n        default:\n            $users = $this->users->fetchAllUsers();\n            break;\n    }\n\n    if (count($users) === 0) {\n        // Show an error message in the console\n        return \"There are no users in the database\\n\";\n    }\n\n    $result = '';\n    foreach ($users as $user) {\n        $result .= $user->name . ' ' . $user->email . \"\\n\";\n    }\n\n    return $result; // show it in the console\n}\n\n\n\nIn the second conditional, we are checking if the users service found any users;\nif not, we return an error message to display immediately, terminating the\napplication.\n\n\nIf any users are found, we loop through each to prepare a listing, which we then\nreturn from the action for display in the console.\n\n\nAre we in a console?\n\n\nSometimes we might need to check if our method is being called from a console or\nfrom a web request. This is useful to block certain methods from running in the\nconsole or to change their behavior based on that context.\n\n\nHere is an example of how to check if we are dealing with a console request:\n\n\nnamespace Application\\Controller;\n\nuse Zend\\Mvc\\Controller\\AbstractActionController;\nuse Zend\\View\\Model\\ViewModel;\nuse Zend\\Console\\Request as ConsoleRequest;\nuse RuntimeException;\n\nclass IndexController extends AbstractActionController\n{\n    public function showUsersAction()\n    {\n        $request = $this->getRequest();\n\n        // Make sure that we are running in a console and the user has not tricked our\n        // application into running this action from a public web server.\n        if (! $request instanceof ConsoleRequest) {\n            throw new RuntimeException(\n                'You can only use this action from a console!'\n            );\n        }\n\n        /* ... */\n    }\n}\n\n\n\n\n\nUse routing to protect methods\n\n\nYou do not need to secure all your controllers and methods from console\nrequests. Controller actions will \nonly be invoked\n when at least one\nconsole route matches it.  HTTP and Console routes are separated and defined\nin different places in module (and application) configuration.\n\n\nThere is no way to invoke a console action unless there is at least one route\npointing to it.  Similarly, there is no way for an HTTP action to be invoked\nunless there is at least one HTTP route that points to it.\n\n\n\n\nThe example below shows how a single controller method can handle \nboth Console\nand HTTP requests\n:\n\n\nnamespace Application\\Controller;\n\nuse Zend\\Mvc\\Controller\\AbstractActionController;\nuse Zend\\View\\Model\\ViewModel;\nuse Zend\\Console\\Request as ConsoleRequest;\nuse Zend\\Http\\Request as HttpRequest;\nuse RuntimeException;\n\nclass IndexController extends AbstractActionController\n{\n    public function showUsersAction()\n    {\n        $request = $this->getRequest();\n\n        $users = [];\n        /* ... fetch users from database ... */\n\n        if ($request instanceof HttpRequest) {\n            // display a web page with users list\n            return new ViewModel($result);\n        }\n\n        if ($request instanceof ConsoleRequest) {\n            // ... prepare console output and return it ...\n            return $result;\n        }\n\n        throw new RuntimeException(\n            'Cannot handle request of type ' . get_class($request)\n        );\n    }\n}\n\n\n\n\n\nAbstractConsoleController\n\n\nThe best way to ensure you always receive a console request instance is to extend\n\nZend\\Mvc\\Controller\\AbstractConsoleController\n. This controller instance also\nexposes a new method, \ngetConsole()\n, providing you access to the console\nadapter, allowing you to use prompts, send output (including colorized output),\nand more.\n\n\n\n\nReading values from console parameters\n\n\nThere are several types of parameters recognized by the Console component, all\nof which are described in the \nconsole routing chapter\n.\nHere, we'll focus on how to retrieve values from distinct parameters and flags.\n\n\nPositional parameters\n\n\nAfter a route matches, we can access both \nliteral parameters\n and \nvalue\nparameters\n via the \n$request\n instance, using the \ngetParam()\n method.\n\n\nAssuming we have the following route:\n\n\n'show-users' => [\n    'options' => [\n        'route'    => 'show (all|deleted|locked|admin) [<groupName>]',\n        'defaults' => [\n            'controller' => 'Application\\Controller\\Users',\n            'action'     => 'showusers',\n        ],\n    ],\n],\n\n\n\nIf this route matches, our action can now query parameters in the following way:\n\n\n// an action inside Application\\Controller\\UsersController:\npublic function showUsersAction()\n{\n    $request = $this->getRequest();\n\n    // We can access named value parameters directly by their name:\n    $showUsersFromGroup = $request->getParam('groupName');\n\n    // Literal parameters can be checked with isset() against their exact spelling\n    if (isset($request->getParam('all'))) {\n        // show all users\n    } elseif (isset($request->getParam('deleted'))) {\n        // show deleted users\n    }\n\n    /* ... */\n}\n\n\n\nIn case of parameter alternatives, it is a good idea to \nassign a name to the group\n, which\nsimplifies the branching in our action controllers. We can do this with the following syntax:\n\n\n// inside of config.console.router.routes:\n'show-users' => [\n    'options' => [\n        'route'    => 'show (all|deleted|locked|admin):userTypeFilter [<groupName>]',\n        'defaults' => [\n            'controller' => 'Application\\Controller\\Users',\n            'action'     => 'showusers',\n        ],\n    ],\n]\n\n\n\nNow we can use a the group name \nuserTypeFilter\n to check which option has been\nselected by the user:\n\n\npublic function showUsersAction()\n{\n    $request = $this->getRequest();\n\n    // We can access named value parameters directly by their name:\n    $showUsersFromGroup = $request->getParam('groupName');\n\n    // The selected option from second parameter is now stored under 'userTypeFilter'\n    $userTypeFilter = $request->getParam('userTypeFilter');\n\n    switch ($userTypeFilter) {\n        case 'all':\n            // all users\n\n        case 'deleted':\n            // deleted users\n\n        case 'locked':\n            // ...\n            // ...\n    }\n}\n\n\n\nFlags\n\n\nFlags are directly accessible by name. Value-capturing flags will contain string\nvalues, as provided by the user. Non-value flags will be equal to \ntrue\n, or\n\nnull\n if not present.\n\n\nGiven the following route:\n\n\n'find-user' => [\n    'options' => [\n        'route'    => 'find user [--fast] [--verbose] [--id=] [--firstName=] [--lastName=] [--email=]',\n        'defaults' => [\n            'controller' => 'Application\\Controller\\Users',\n            'action'     => 'find',\n        ],\n    ],\n],\n\n\n\nWe can retrieve values in the following fashion:\n\n\npublic function findAction()\n{\n    $request = $this->getRequest();\n\n    // We can retrieve values from value flags using their name\n    $searchId        = $request->getParam('id', null); // default null\n    $searchFirstName = $request->getParam('firstName', null);\n    $searchLastName  = $request->getParam('lastName', null);\n    $searchEmail     = $request->getParam('email', null);\n\n    // Standard flags that have been matched will be equal to TRUE\n    $isFast    = (bool)$request->getParam('fast', false); // default false\n    $isVerbose = (bool)$request->getParam('verbose', false);\n\n    if ($isFast) {\n        // perform a fast query ...\n    } else {\n        // perform standard query ...\n    }\n}\n\n\n\nIn case of \nflag alternatives\n, we have to check each alternative separately:\n\n\n/*\n * Assuming our route now reads:\n *      'route'    => 'find user [--fast|-f] [--verbose|-v] ... ',\n */\npublic function findAction()\n{\n    $request = $this->getRequest();\n\n    // Check both alternatives\n    $isFast    = $request->getParam('fast', false)    || $request->getParam('f', false);\n    $isVerbose = $request->getParam('verbose', false) || $request->getParam('v', false);\n\n    // ...\n}",
            "title": "Controllers"
        },
        {
            "location": "/controllers/#console-controllers",
            "text": "When using the zend-mvc integration with zend-console, a matched route results\nin dispatch of an action controller. In this chapter we will learn how ZF2\nControllers can interact with and return output to console window.",
            "title": "Console Controllers"
        },
        {
            "location": "/controllers/#abstractconsolecontroller",
            "text": "zend-mvc-console provides a controller implementation for use with zend-mvc , Zend\\Mvc\\Controller\\AbstractConsoleController . The implementation\nextends from the zend-mvc  AbstractActionController ,\nand provides the following functionality:   The method  setConsole(Zend\\Console\\Adapter\\AdapterInterface $console)  allows\n  injecting a console adapter representing the current console environment. By\n  default, the  ControllerManager  will inject this for you as part of\n  controller instantiation.  The method  getConsole()  allows you to retrieve the current console adapter\n  instance, allowing you to retrieve console capabilities and generate console\n  output.  The  dispatch()  method will throw an exception if invoked in a non-console\n  environment, ensuring that you do not need to do any checks within your action\n  methods for the environment.",
            "title": "AbstractConsoleController"
        },
        {
            "location": "/controllers/#interfaces-and-collaborators",
            "text": "AbstractRestfulController  implements each of the following interfaces:   Zend\\Stdlib\\DispatchableInterface  Zend\\Mvc\\InjectApplicationEventInterface  Zend\\EventManager\\EventManagerAwareInterface   The composed  EventManager  will be configured to listen on the following contexts:   Zend\\Stdlib\\DispatchableInterface  Zend\\Mvc\\Controller\\AbstractConsoleController  Zend\\Mvc\\Controller\\AbstractActionController  Zend\\Mvc\\Controller\\AbstractController   Additionally, if you extend the class, it will listen on the name of the\nextending class.",
            "title": "Interfaces and Collaborators"
        },
        {
            "location": "/controllers/#handling-console-requests",
            "text": "Console requests are very similar to HTTP requests. In fact, they implement a\ncommon interface and are created at the same time in the MVC workflow.  Console routes \nmatch against command line arguments and provide a  defaults  array, which holds\nthe  controller  and  action  keys. These correspond with controller aliases in\nthe  ServiceManager , and method names in the controller class. This is\nanalogous to the way HTTP requests are handled under zend-mvc.  In this example we'll use the following route:  // in file module/Application/config/module.config.php:\nreturn [\n    'router'  => [\n        'routes' => [\n            // HTTP routes are here\n        ],\n    ],\n    'console' => [\n        'router' => [\n            'routes' => [\n                'list-users' => [\n                    'options' => [\n                        'route'    => 'show [all|disabled|deleted]:mode users [--verbose|-v]',\n                        'defaults' => [\n                            'controller' => Application\\Controller\\Index::class,\n                            'action'     => 'show-users',\n                        ],\n                    ],\n                ],\n            ],\n        ],\n    ],\n    /* ... */\n];  This route will match commands such as:  $ php public/index.php show users\n$ php public/index.php show all users\n$ php public/index.php show disabled users  This route maps to the method  Application\\Controller\\IndexController::showUsersAction() .  Let's add that method to our controller.  namespace Application\\Controller;\n\nuse Application\\Model\\Users;\nuse Zend\\Mvc\\Controller\\AbstractActionController;\nuse Zend\\View\\Model\\ViewModel;\n\nclass IndexController extends AbstractActionController\n{\n    private $users;\n\n    public function __construct(Users $users)\n    {\n        $this->users = $users;\n    }\n\n    public function indexAction()\n    {\n        return new ViewModel(); // display standard index page\n    }\n\n    public function showUsersAction()\n    {\n        $request = $this->getRequest();\n\n        // Check verbose flag\n        $verbose = $request->getParam('verbose') || $request->getParam('v');\n\n        // Check mode\n        $mode = $request->getParam('mode', 'all'); // defaults to 'all'\n\n        $users = [];\n        switch ($mode) {\n            case 'disabled':\n                $users = $this->users->fetchDisabledUsers();\n                break;\n\n            case 'deleted':\n                $users = $this->users->fetchDeletedUsers();\n                break;\n\n            case 'all':\n\n            default:\n                $users = $this->users->fetchAllUsers();\n                break;\n        }\n    }\n}  We fetch the console request, read parameters, and load users from our\n(theoretical) users service.  In order to make this method functional, we'll\nhave to display the result in the console window.",
            "title": "Handling console requests"
        },
        {
            "location": "/controllers/#sending-output-to-the-console",
            "text": "The simplest way for our controller to display data in the console window is to\nreturn a string. Let's modify our example to output a list of users:  public function showUsersAction()\n{\n    $request = $this->getRequest();\n\n    // Check verbose flag\n    $verbose = $request->getParam('verbose') || $request->getParam('v');\n\n    // Check mode\n    $mode = $request->getParam('mode', 'all'); // defaults to 'all'\n\n    $users = [];\n    switch ($mode) {\n        case 'disabled':\n            $users = $this->users->fetchDisabledUsers();\n            break;\n\n        case 'deleted':\n            $users = $this->users->fetchDeletedUsers();\n            break;\n\n        case 'all':\n\n        default:\n            $users = $this->users->fetchAllUsers();\n            break;\n    }\n\n    if (count($users) === 0) {\n        // Show an error message in the console\n        return \"There are no users in the database\\n\";\n    }\n\n    $result = '';\n    foreach ($users as $user) {\n        $result .= $user->name . ' ' . $user->email . \"\\n\";\n    }\n\n    return $result; // show it in the console\n}  In the second conditional, we are checking if the users service found any users;\nif not, we return an error message to display immediately, terminating the\napplication.  If any users are found, we loop through each to prepare a listing, which we then\nreturn from the action for display in the console.",
            "title": "Sending output to the console"
        },
        {
            "location": "/controllers/#are-we-in-a-console",
            "text": "Sometimes we might need to check if our method is being called from a console or\nfrom a web request. This is useful to block certain methods from running in the\nconsole or to change their behavior based on that context.  Here is an example of how to check if we are dealing with a console request:  namespace Application\\Controller;\n\nuse Zend\\Mvc\\Controller\\AbstractActionController;\nuse Zend\\View\\Model\\ViewModel;\nuse Zend\\Console\\Request as ConsoleRequest;\nuse RuntimeException;\n\nclass IndexController extends AbstractActionController\n{\n    public function showUsersAction()\n    {\n        $request = $this->getRequest();\n\n        // Make sure that we are running in a console and the user has not tricked our\n        // application into running this action from a public web server.\n        if (! $request instanceof ConsoleRequest) {\n            throw new RuntimeException(\n                'You can only use this action from a console!'\n            );\n        }\n\n        /* ... */\n    }\n}",
            "title": "Are we in a console?"
        },
        {
            "location": "/controllers/#use-routing-to-protect-methods",
            "text": "You do not need to secure all your controllers and methods from console\nrequests. Controller actions will  only be invoked  when at least one\nconsole route matches it.  HTTP and Console routes are separated and defined\nin different places in module (and application) configuration.  There is no way to invoke a console action unless there is at least one route\npointing to it.  Similarly, there is no way for an HTTP action to be invoked\nunless there is at least one HTTP route that points to it.   The example below shows how a single controller method can handle  both Console\nand HTTP requests :  namespace Application\\Controller;\n\nuse Zend\\Mvc\\Controller\\AbstractActionController;\nuse Zend\\View\\Model\\ViewModel;\nuse Zend\\Console\\Request as ConsoleRequest;\nuse Zend\\Http\\Request as HttpRequest;\nuse RuntimeException;\n\nclass IndexController extends AbstractActionController\n{\n    public function showUsersAction()\n    {\n        $request = $this->getRequest();\n\n        $users = [];\n        /* ... fetch users from database ... */\n\n        if ($request instanceof HttpRequest) {\n            // display a web page with users list\n            return new ViewModel($result);\n        }\n\n        if ($request instanceof ConsoleRequest) {\n            // ... prepare console output and return it ...\n            return $result;\n        }\n\n        throw new RuntimeException(\n            'Cannot handle request of type ' . get_class($request)\n        );\n    }\n}",
            "title": "Use routing to protect methods"
        },
        {
            "location": "/controllers/#abstractconsolecontroller_1",
            "text": "The best way to ensure you always receive a console request instance is to extend Zend\\Mvc\\Controller\\AbstractConsoleController . This controller instance also\nexposes a new method,  getConsole() , providing you access to the console\nadapter, allowing you to use prompts, send output (including colorized output),\nand more.",
            "title": "AbstractConsoleController"
        },
        {
            "location": "/controllers/#reading-values-from-console-parameters",
            "text": "There are several types of parameters recognized by the Console component, all\nof which are described in the  console routing chapter .\nHere, we'll focus on how to retrieve values from distinct parameters and flags.",
            "title": "Reading values from console parameters"
        },
        {
            "location": "/controllers/#positional-parameters",
            "text": "After a route matches, we can access both  literal parameters  and  value\nparameters  via the  $request  instance, using the  getParam()  method.  Assuming we have the following route:  'show-users' => [\n    'options' => [\n        'route'    => 'show (all|deleted|locked|admin) [<groupName>]',\n        'defaults' => [\n            'controller' => 'Application\\Controller\\Users',\n            'action'     => 'showusers',\n        ],\n    ],\n],  If this route matches, our action can now query parameters in the following way:  // an action inside Application\\Controller\\UsersController:\npublic function showUsersAction()\n{\n    $request = $this->getRequest();\n\n    // We can access named value parameters directly by their name:\n    $showUsersFromGroup = $request->getParam('groupName');\n\n    // Literal parameters can be checked with isset() against their exact spelling\n    if (isset($request->getParam('all'))) {\n        // show all users\n    } elseif (isset($request->getParam('deleted'))) {\n        // show deleted users\n    }\n\n    /* ... */\n}  In case of parameter alternatives, it is a good idea to  assign a name to the group , which\nsimplifies the branching in our action controllers. We can do this with the following syntax:  // inside of config.console.router.routes:\n'show-users' => [\n    'options' => [\n        'route'    => 'show (all|deleted|locked|admin):userTypeFilter [<groupName>]',\n        'defaults' => [\n            'controller' => 'Application\\Controller\\Users',\n            'action'     => 'showusers',\n        ],\n    ],\n]  Now we can use a the group name  userTypeFilter  to check which option has been\nselected by the user:  public function showUsersAction()\n{\n    $request = $this->getRequest();\n\n    // We can access named value parameters directly by their name:\n    $showUsersFromGroup = $request->getParam('groupName');\n\n    // The selected option from second parameter is now stored under 'userTypeFilter'\n    $userTypeFilter = $request->getParam('userTypeFilter');\n\n    switch ($userTypeFilter) {\n        case 'all':\n            // all users\n\n        case 'deleted':\n            // deleted users\n\n        case 'locked':\n            // ...\n            // ...\n    }\n}",
            "title": "Positional parameters"
        },
        {
            "location": "/controllers/#flags",
            "text": "Flags are directly accessible by name. Value-capturing flags will contain string\nvalues, as provided by the user. Non-value flags will be equal to  true , or null  if not present.  Given the following route:  'find-user' => [\n    'options' => [\n        'route'    => 'find user [--fast] [--verbose] [--id=] [--firstName=] [--lastName=] [--email=]',\n        'defaults' => [\n            'controller' => 'Application\\Controller\\Users',\n            'action'     => 'find',\n        ],\n    ],\n],  We can retrieve values in the following fashion:  public function findAction()\n{\n    $request = $this->getRequest();\n\n    // We can retrieve values from value flags using their name\n    $searchId        = $request->getParam('id', null); // default null\n    $searchFirstName = $request->getParam('firstName', null);\n    $searchLastName  = $request->getParam('lastName', null);\n    $searchEmail     = $request->getParam('email', null);\n\n    // Standard flags that have been matched will be equal to TRUE\n    $isFast    = (bool)$request->getParam('fast', false); // default false\n    $isVerbose = (bool)$request->getParam('verbose', false);\n\n    if ($isFast) {\n        // perform a fast query ...\n    } else {\n        // perform standard query ...\n    }\n}  In case of  flag alternatives , we have to check each alternative separately:  /*\n * Assuming our route now reads:\n *      'route'    => 'find user [--fast|-f] [--verbose|-v] ... ',\n */\npublic function findAction()\n{\n    $request = $this->getRequest();\n\n    // Check both alternatives\n    $isFast    = $request->getParam('fast', false)    || $request->getParam('f', false);\n    $isVerbose = $request->getParam('verbose', false) || $request->getParam('v', false);\n\n    // ...\n}",
            "title": "Flags"
        },
        {
            "location": "/modules/",
            "text": "Console-aware modules\n\n\nzend-mvc-console integrates zend-mvc with zend-console; the integration also works with modules\nloaded with the\n\nModule Manager\n.\n\n\nzend-mvc-console ships with a console-specific \nRouteNotFoundStrategy\n which is\nresponsible for displaying console usage information when:\n\n\n\n\nthe user has not provided any arguments; or\n\n\narguments could not be matched by any routes.\n\n\n\n\nThe strategy currently supports two types of information:\n\napplication banners\n and \nusage information\n.\n\n\nApplication banner\n\n\nWhen using the console within a zend-mvc-console-enabled application, you can\ninvoke it via the application bootstrap:\n\n\n$ php public/index.php\n\n\n\nBy default, it will simply output the current ZF 2 version, like this:\n\n\n\n\nOur \nApplication\n module (and any other module) can provide an \napplication\nbanner\n. In order to do so, our \nModule\n class has to implement\n\nZend\\ModuleManager\\Feature\\ConsoleBannerProviderInterface\n. As an example:\n\n\n// module/Application/Module.php\n<?php\nnamespace Application;\n\nuse Zend\\ModuleManager\\Feature\\ConsoleBannerProviderInterface;\nuse Zend\\Console\\Adapter\\AdapterInterface as Console;\n\nclass Module implements ConsoleBannerProviderInterface\n{\n    /**\n     * This method is defined in ConsoleBannerProviderInterface\n     */\n    public function getConsoleBanner(Console $console)\n    {\n        return 'MyModule 0.0.1';\n    }\n}\n\n\n\n\n\nDuck-typing allowed\n\n\nYou can duck-type the interface implementation by implementing the\n\ngetConsoleBanner()\n method without specifically implementing the\n\nConsoleBannerProviderInterface\n.\n\n\n\n\nAs you can see, the application banner should be a single line string that\nreturns the module's name and (if available) its current version.\n\n\nIf several modules define their own banner, they are displayed one after the\nother in the order in which the modules are loaded. This allows you to see at a\nglance which modules expose console commands.\n\n\nIf we execute our console application now, we'll see the newly created banner:\n\n\n\n\nLet's create and load a second module that provides a banner:\n\n\n<?php\n// config/application.config.php\nreturn [\n    'modules' => [\n        'Application',\n        'User', // <- load user module in module/User\n    ],\n    // ...\n];\n\n\n\nThe \nUser\n module will provide info about itself:\n\n\n// module/User/Module.php\n<?php\nnamespace User;\n\nuse Zend\\ModuleManager\\Feature\\ConsoleBannerProviderInterface;\nuse Zend\\Console\\Adapter\\AdapterInterface as Console;\n\nclass Module implements ConsoleBannerProviderInterface\n{\n    /**\n     * This method is defined in ConsoleBannerProviderInterface\n     */\n    public function getConsoleBanner(Console $console)\n    {\n        return \"User Module 0.0.1\";\n    }\n}\n\n\n\nBecause the \nUser\n module is loaded after the \nApplication\n module, the result\nwill look like this:\n\n\n\n\n\n\nApplication banner display\n\n\nApplication banners provided by modules are displayed as-is \u2014 no\ntrimming or other adjustments will be performed on the text. As you can see,\nbanners are also automatically colorized as blue.\n\n\n\n\nUsage information\n\n\nIn order to display usage information, our Module class must implement\n\nZend\\ModuleManager\\Feature\\ConsoleUsageProviderInterface\n. Let's modify our\nexample and add the new method defined in that interface:\n\n\n// module/Application/Module.php\n<?php\nnamespace Application;\n\nuse Zend\\ModuleManager\\Feature\\ConsoleBannerProviderInterface;\nuse Zend\\ModuleManager\\Feature\\ConsoleUsageProviderInterface;\nuse Zend\\Console\\Adapter\\AdapterInterface as Console;\n\nclass Module implements\n    ConsoleBannerProviderInterface,\n    ConsoleUsageProviderInterface\n{\n    public function getConsoleBanner(Console $console)\n    {\n        /* ... */\n    }\n\n    /**\n     * This method is defined in ConsoleUsageProviderInterface\n     */\n    public function getConsoleUsage(Console $console)\n    {\n        return [\n            'show stats'             => 'Show application statistics',\n            'run cron'               => 'Run automated jobs',\n            '(enable|disable) debug' => 'Enable or disable debug mode for the application.',\n        ];\n    }\n}\n\n\n\n\n\nDuck-typing allowed\n\n\nYou can duck-type the interface implementation by implementing the\n\ngetConsoleUsage()\n method without specifically implementing the\n\nConsoleUsageProviderInterface\n.\n\n\n\n\nThis will display the following information:\n\n\n\n\nSimilar to \napplication banners\n, multiple modules can\nprovide usage information, which will be joined together and displayed to the\nuser. The order in which usage information is displayed is the order in which\nmodules are loaded.\n\n\nAs you can see, the zend-mvc-console integration also prepends each module's\nusage with the module's name. This helps to visually separate commands by module\n\u2014 which is particularly useful when you have multiple modules providing\ncommands.  By default, the component colorizes the module names in red.\n\n\n\n\nUsage information is arbitrary\n\n\nUsage info provided in modules is not connected with \nconsole\nrouting\n. You can describe console usage in any form you prefer,\nand it does not affect how MVC handles console commands. In order to handle\nreal console requests, you still need to define console routes.\n\n\n\n\nFree-form text\n\n\nIn order to output free-form text as usage information, \ngetConsoleUsage()\n can\nreturn a string or an array of strings. As an example, the following is a\nsingle, free-form usage text:\n\n\npublic function getConsoleUsage(Console $console)\n{\n    return 'User module expects exactly one argument - user name. '\n        . 'It will display information for the provided user.';\n}\n\n\n\n\n\n\n\nUsage text is provided as-is\n\n\nThe text provided is displayed as-is; no trimming or other adjustments will\nbe performed. If you'd like to fit your usage information inside the console\nwindow, you could check its width with \n$console-getWidth()\n.\n\n\n\n\nList of commands\n\n\nIf \ngetConsoleUsage()\n returns an associative array, it will be automatically\naligned in 2 columns.  The first column will be prepended with script name (the\nentry point for the application). This is useful to display the various\ncommands exposed.\n\n\npublic function getConsoleUsage(Console $console)\n{\n     return [\n        'delete user <userEmail>'        => 'Delete user with email <userEmail>',\n        'disable user <userEmail>'       => 'Disable user with email <userEmail>',\n        'list [all|disabled] users'      => 'Show a list of users',\n        'find user [--email=] [--name=]' => 'Attempt to find a user by email or name',\n     ];\n}\n\n\n\n\n\n\n\nCommand list alignment\n\n\nCommands and their descriptions will be aligned in two columns that fit\ninside the terminal window. If the window is resized, text may wrap, but all\ncontent will be aligned. If you don't like the behavior, you can always\nreturn \nfree-form text\n instead, as free-form text is never\ntransformed or aligned.\n\n\n\n\nList of params and flags\n\n\nReturning an array of arrays from \ngetConsoleUsage()\n will produce a listing of\nparameters. This is useful for explaining flags, switches, possible values and\nother information. The output will be aligned in multiple columns for\nreadability.\n\n\nAs an example:\n\n\npublic function getConsoleUsage(Console $console)\n{\n    return [\n        [ '<userEmail>', 'email of the user' ],\n        [ '--verbose',   'Turn on verbose mode' ],\n        [ '--quick',     'Perform a \"quick\" operation' ],\n        [ '-v',          'Same as --verbose' ],\n        [ '-w',          'Wide output'],\n    ];\n}\n\n\n\n\n\nThis method can be used to display more than 2 columns of information:\n\n\npublic function getConsoleUsage(Console $console)\n{\n    return [\n        [ '<userEmail>', 'user email',        'Full email address of the user to find.' ],\n        [ '--verbose',   'verbose mode',      'Display additional information during processing' ],\n        [ '--quick',     '\"quick\" operation', 'Do not check integrity, just make changes and finish' ],\n        [ '-v',          'Same as --verbose', 'Display additional information during processing' ],\n        [ '-w',          'wide output',       'When listing users, use the whole available screen width' ],\n    ];\n}\n\n\n\n\n\n\n\nAlignment\n\n\nAll information will be aligned in one or more columns that fit inside the\nterminal window. If the window is resized, some text may wrap, but all\ncontent will remain aligned. In case the number of columns changes (e.g. the\narray contains different number of elements), a new table will be created,\nwith its own alignment and column widths.\n\n\nIf you don't like this behavior, you can always return \nfree-form text\n.\n\n\n\n\nMixing styles\n\n\nYou can use mix together all of the above styles to provide comprehensive usage information.\n\n\npublic function getConsoleUsage(Console $console)\n{\n    return [\n        'Finding and listing users',\n        'list [all|disabled] users [-w]' => 'Show a list of users',\n        'find user [--email=] [--name=]' => 'Attempt to find a user by email or name',\n\n        ['[all|disabled]', 'Display all users or only disabled accounts'],\n        ['--email=EMAIL',  'Email of the user to find'],\n        ['--name=NAME',    'Full name of the user to find.'],\n        ['-w',             'Wide output - When listing users use the whole available screen width'],\n\n        'Manipulation of user database:',\n        'delete user <userEmail> [--verbose|-v] [--quick]' => 'Delete user with email <userEmail>',\n        'disable user <userEmail> [--verbose|-v]'          => 'Disable user with email <userEmail>',\n\n        [ '<userEmail>', 'user email',        'Full email address of the user to change.'],\n        [ '--verbose',   'verbose mode',      'Display additional information during processing'],\n        [ '--quick',     '\"quick\" operation', 'Do not check integrity, just make changes and finish'],\n        [ '-v',          'Same as --verbose', 'Display additional information during processing'],\n\n    ];\n}\n\n\n\n\n\nBest practices\n\n\nHere are the best practices when providing usage for your commands:\n\n\n\n\nYour module's \ngetConsoleBanner()\n method should return a one-line string\n   containing the module's name and its version (if available); do not provide any\n   other information.\n\n\nYour \ngetConsoleUsage()\n method should \nnot\n return the module's name, as it\n   is prepended automatically for you by the zend-mvc-console integration.",
            "title": "Modules"
        },
        {
            "location": "/modules/#console-aware-modules",
            "text": "zend-mvc-console integrates zend-mvc with zend-console; the integration also works with modules\nloaded with the Module Manager .  zend-mvc-console ships with a console-specific  RouteNotFoundStrategy  which is\nresponsible for displaying console usage information when:   the user has not provided any arguments; or  arguments could not be matched by any routes.   The strategy currently supports two types of information: application banners  and  usage information .",
            "title": "Console-aware modules"
        },
        {
            "location": "/modules/#application-banner",
            "text": "When using the console within a zend-mvc-console-enabled application, you can\ninvoke it via the application bootstrap:  $ php public/index.php  By default, it will simply output the current ZF 2 version, like this:   Our  Application  module (and any other module) can provide an  application\nbanner . In order to do so, our  Module  class has to implement Zend\\ModuleManager\\Feature\\ConsoleBannerProviderInterface . As an example:  // module/Application/Module.php\n<?php\nnamespace Application;\n\nuse Zend\\ModuleManager\\Feature\\ConsoleBannerProviderInterface;\nuse Zend\\Console\\Adapter\\AdapterInterface as Console;\n\nclass Module implements ConsoleBannerProviderInterface\n{\n    /**\n     * This method is defined in ConsoleBannerProviderInterface\n     */\n    public function getConsoleBanner(Console $console)\n    {\n        return 'MyModule 0.0.1';\n    }\n}",
            "title": "Application banner"
        },
        {
            "location": "/modules/#duck-typing-allowed",
            "text": "You can duck-type the interface implementation by implementing the getConsoleBanner()  method without specifically implementing the ConsoleBannerProviderInterface .   As you can see, the application banner should be a single line string that\nreturns the module's name and (if available) its current version.  If several modules define their own banner, they are displayed one after the\nother in the order in which the modules are loaded. This allows you to see at a\nglance which modules expose console commands.  If we execute our console application now, we'll see the newly created banner:   Let's create and load a second module that provides a banner:  <?php\n// config/application.config.php\nreturn [\n    'modules' => [\n        'Application',\n        'User', // <- load user module in module/User\n    ],\n    // ...\n];  The  User  module will provide info about itself:  // module/User/Module.php\n<?php\nnamespace User;\n\nuse Zend\\ModuleManager\\Feature\\ConsoleBannerProviderInterface;\nuse Zend\\Console\\Adapter\\AdapterInterface as Console;\n\nclass Module implements ConsoleBannerProviderInterface\n{\n    /**\n     * This method is defined in ConsoleBannerProviderInterface\n     */\n    public function getConsoleBanner(Console $console)\n    {\n        return \"User Module 0.0.1\";\n    }\n}  Because the  User  module is loaded after the  Application  module, the result\nwill look like this:",
            "title": "Duck-typing allowed"
        },
        {
            "location": "/modules/#application-banner-display",
            "text": "Application banners provided by modules are displayed as-is \u2014 no\ntrimming or other adjustments will be performed on the text. As you can see,\nbanners are also automatically colorized as blue.",
            "title": "Application banner display"
        },
        {
            "location": "/modules/#usage-information",
            "text": "In order to display usage information, our Module class must implement Zend\\ModuleManager\\Feature\\ConsoleUsageProviderInterface . Let's modify our\nexample and add the new method defined in that interface:  // module/Application/Module.php\n<?php\nnamespace Application;\n\nuse Zend\\ModuleManager\\Feature\\ConsoleBannerProviderInterface;\nuse Zend\\ModuleManager\\Feature\\ConsoleUsageProviderInterface;\nuse Zend\\Console\\Adapter\\AdapterInterface as Console;\n\nclass Module implements\n    ConsoleBannerProviderInterface,\n    ConsoleUsageProviderInterface\n{\n    public function getConsoleBanner(Console $console)\n    {\n        /* ... */\n    }\n\n    /**\n     * This method is defined in ConsoleUsageProviderInterface\n     */\n    public function getConsoleUsage(Console $console)\n    {\n        return [\n            'show stats'             => 'Show application statistics',\n            'run cron'               => 'Run automated jobs',\n            '(enable|disable) debug' => 'Enable or disable debug mode for the application.',\n        ];\n    }\n}",
            "title": "Usage information"
        },
        {
            "location": "/modules/#duck-typing-allowed_1",
            "text": "You can duck-type the interface implementation by implementing the getConsoleUsage()  method without specifically implementing the ConsoleUsageProviderInterface .   This will display the following information:   Similar to  application banners , multiple modules can\nprovide usage information, which will be joined together and displayed to the\nuser. The order in which usage information is displayed is the order in which\nmodules are loaded.  As you can see, the zend-mvc-console integration also prepends each module's\nusage with the module's name. This helps to visually separate commands by module\n\u2014 which is particularly useful when you have multiple modules providing\ncommands.  By default, the component colorizes the module names in red.",
            "title": "Duck-typing allowed"
        },
        {
            "location": "/modules/#usage-information-is-arbitrary",
            "text": "Usage info provided in modules is not connected with  console\nrouting . You can describe console usage in any form you prefer,\nand it does not affect how MVC handles console commands. In order to handle\nreal console requests, you still need to define console routes.",
            "title": "Usage information is arbitrary"
        },
        {
            "location": "/modules/#free-form-text",
            "text": "In order to output free-form text as usage information,  getConsoleUsage()  can\nreturn a string or an array of strings. As an example, the following is a\nsingle, free-form usage text:  public function getConsoleUsage(Console $console)\n{\n    return 'User module expects exactly one argument - user name. '\n        . 'It will display information for the provided user.';\n}",
            "title": "Free-form text"
        },
        {
            "location": "/modules/#usage-text-is-provided-as-is",
            "text": "The text provided is displayed as-is; no trimming or other adjustments will\nbe performed. If you'd like to fit your usage information inside the console\nwindow, you could check its width with  $console-getWidth() .",
            "title": "Usage text is provided as-is"
        },
        {
            "location": "/modules/#list-of-commands",
            "text": "If  getConsoleUsage()  returns an associative array, it will be automatically\naligned in 2 columns.  The first column will be prepended with script name (the\nentry point for the application). This is useful to display the various\ncommands exposed.  public function getConsoleUsage(Console $console)\n{\n     return [\n        'delete user <userEmail>'        => 'Delete user with email <userEmail>',\n        'disable user <userEmail>'       => 'Disable user with email <userEmail>',\n        'list [all|disabled] users'      => 'Show a list of users',\n        'find user [--email=] [--name=]' => 'Attempt to find a user by email or name',\n     ];\n}",
            "title": "List of commands"
        },
        {
            "location": "/modules/#command-list-alignment",
            "text": "Commands and their descriptions will be aligned in two columns that fit\ninside the terminal window. If the window is resized, text may wrap, but all\ncontent will be aligned. If you don't like the behavior, you can always\nreturn  free-form text  instead, as free-form text is never\ntransformed or aligned.",
            "title": "Command list alignment"
        },
        {
            "location": "/modules/#list-of-params-and-flags",
            "text": "Returning an array of arrays from  getConsoleUsage()  will produce a listing of\nparameters. This is useful for explaining flags, switches, possible values and\nother information. The output will be aligned in multiple columns for\nreadability.  As an example:  public function getConsoleUsage(Console $console)\n{\n    return [\n        [ '<userEmail>', 'email of the user' ],\n        [ '--verbose',   'Turn on verbose mode' ],\n        [ '--quick',     'Perform a \"quick\" operation' ],\n        [ '-v',          'Same as --verbose' ],\n        [ '-w',          'Wide output'],\n    ];\n}   This method can be used to display more than 2 columns of information:  public function getConsoleUsage(Console $console)\n{\n    return [\n        [ '<userEmail>', 'user email',        'Full email address of the user to find.' ],\n        [ '--verbose',   'verbose mode',      'Display additional information during processing' ],\n        [ '--quick',     '\"quick\" operation', 'Do not check integrity, just make changes and finish' ],\n        [ '-v',          'Same as --verbose', 'Display additional information during processing' ],\n        [ '-w',          'wide output',       'When listing users, use the whole available screen width' ],\n    ];\n}",
            "title": "List of params and flags"
        },
        {
            "location": "/modules/#alignment",
            "text": "All information will be aligned in one or more columns that fit inside the\nterminal window. If the window is resized, some text may wrap, but all\ncontent will remain aligned. In case the number of columns changes (e.g. the\narray contains different number of elements), a new table will be created,\nwith its own alignment and column widths.  If you don't like this behavior, you can always return  free-form text .",
            "title": "Alignment"
        },
        {
            "location": "/modules/#mixing-styles",
            "text": "You can use mix together all of the above styles to provide comprehensive usage information.  public function getConsoleUsage(Console $console)\n{\n    return [\n        'Finding and listing users',\n        'list [all|disabled] users [-w]' => 'Show a list of users',\n        'find user [--email=] [--name=]' => 'Attempt to find a user by email or name',\n\n        ['[all|disabled]', 'Display all users or only disabled accounts'],\n        ['--email=EMAIL',  'Email of the user to find'],\n        ['--name=NAME',    'Full name of the user to find.'],\n        ['-w',             'Wide output - When listing users use the whole available screen width'],\n\n        'Manipulation of user database:',\n        'delete user <userEmail> [--verbose|-v] [--quick]' => 'Delete user with email <userEmail>',\n        'disable user <userEmail> [--verbose|-v]'          => 'Disable user with email <userEmail>',\n\n        [ '<userEmail>', 'user email',        'Full email address of the user to change.'],\n        [ '--verbose',   'verbose mode',      'Display additional information during processing'],\n        [ '--quick',     '\"quick\" operation', 'Do not check integrity, just make changes and finish'],\n        [ '-v',          'Same as --verbose', 'Display additional information during processing'],\n\n    ];\n}",
            "title": "Mixing styles"
        },
        {
            "location": "/modules/#best-practices",
            "text": "Here are the best practices when providing usage for your commands:   Your module's  getConsoleBanner()  method should return a one-line string\n   containing the module's name and its version (if available); do not provide any\n   other information.  Your  getConsoleUsage()  method should  not  return the module's name, as it\n   is prepended automatically for you by the zend-mvc-console integration.",
            "title": "Best practices"
        },
        {
            "location": "/listeners/",
            "text": "MVC Listeners\n\n\nzend-mvc-console registers a number of listeners with zend-mvc applications.\nBelow is a list of events, and the listeners zend-mvc-console registers.\n\n\nMvcEvent::EVENT_BOOTSTRAP\n (\"bootstrap\")\n\n\nListeners\n\n\nThe following classes listen to this event (sorted from higher priority to lower\npriority):\n\n\n\n\n\n\n\n\nClass\n\n\nPriority\n\n\nMethod Called\n\n\nTriggers\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nZend\\Mvc\\Console\\View\\ViewManager\n\n\n10000\n\n\nonBootstrap\n\n\nnone\n\n\nPrepares the view layer.\n\n\n\n\n\n\n\n\nTriggered By\n\n\nThis event is triggered by the following classes:\n\n\n\n\n\n\n\n\nClass\n\n\nIn Method\n\n\n\n\n\n\n\n\n\n\nZend\\Mvc\\Application\n\n\nbootstrap\n\n\n\n\n\n\n\n\nMvcEvent::EVENT_DISPATCH\n (\"dispatch\")\n\n\nListeners\n\n\nThe following classes listen to this event (sorted from higher priority to lower\npriority):\n\n\n\n\n\n\n\n\nClass\n\n\nPriority\n\n\nMethod Called\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nZend\\Mvc\\Console\\View\\InjectNamedConsoleParamsListener\n\n\n1000\n\n\ninjectNamedParams\n\n\nMerge all params (route match params and params in the command), and add them to the \nRequest\n object.\n\n\n\n\n\n\nZend\\Mvc\\Console\\View\\CreateViewModelListener\n\n\n-80\n\n\ncreateViewModelFromArray\n\n\nIf the controller action returns an associative array, this listener casts it to a \nZend\\Mvc\\Console\\View\\ViewModel\n object.\n\n\n\n\n\n\nZend\\Mvc\\Console\\View\\CreateViewModelListener\n\n\n-80\n\n\ncreateViewModelFromString\n\n\nIf the controller action returns a string, this listener casts it to a \nZend\\Mvc\\Console\\View\\ViewModel\n object.\n\n\n\n\n\n\nZend\\Mvc\\Console\\View\\CreateViewModelListener\n\n\n-80\n\n\ncreateViewModelFromNull\n\n\nIf the controller action returns null, this listener casts it to a \nZend\\Mvc\\Console\\View\\ViewModel\n object.\n\n\n\n\n\n\nZend\\Mvc\\Console\\View\\InjectViewModelListener\n\n\n-100\n\n\ninjectViewModel\n\n\nInserts the \nViewModel\n (in this case, a \nZend\\Mvc\\Console\\View\\ViewModel\n) and adds it to the \nMvcEvent\n object. It either (a) adds it as a child to the default, composed view model, or (b) replaces it if the result is marked as terminal.\n\n\n\n\n\n\n\n\nTriggered By\n\n\nThis event is triggered by the following classes:\n\n\n\n\n\n\n\n\nClass\n\n\nIn Method\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nZend\\Mvc\\Application\n\n\nrun\n\n\nUses a short circuit callback to halt propagation of the event if an error is raised during routing.\n\n\n\n\n\n\nZend\\Mvc\\Controller\\AbstractController\n\n\ndispatch\n\n\nIf a listener returns a \nResponse\n object, it halts propagation. Note: every \nAbstractController\n listens to this event and executes the \nonDispatch\n method when it is triggered.\n\n\n\n\n\n\n\n\nMvcEvent::EVENT_DISPATCH_ERROR\n (\"dispatch.error\")\n\n\nListeners\n\n\nThe following classes listen to this event (sorted from higher priority to lower\npriority):\n\n\n\n\n\n\n\n\nClass\n\n\nPriority\n\n\nMethod Called\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nZend\\Mvc\\Console\\View\\RouteNotFoundStrategy\n\n\n1\n\n\nhandleRouteNotFoundError\n\n\nDetect if an error is a \"route not found\" condition, and display a usage message.\n\n\n\n\n\n\nZend\\Mvc\\Console\\View\\ExceptionStrategy\n\n\n1\n\n\nprepareExceptionViewModel\n\n\nCreate an exception view model.\n\n\n\n\n\n\nZend\\Mvc\\Console\\View\\InjectViewModelListener\n\n\n-100\n\n\ninjectViewModel\n\n\nInserts the \nViewModel\n (in this case, a \nZend\\Mvc\\Console\\View\\ViewModel\n) and adds it to the \nMvcEvent\n object. It either (a) adds it as a child to the default, composed view model, or (b) replaces it if the result is marked as terminable.\n\n\n\n\n\n\n\n\nTriggered By\n\n\n\n\n\n\n\n\nClass\n\n\nIn Method\n\n\n\n\n\n\n\n\n\n\nZend\\Mvc\\MiddlewareListener\n\n\nonDispatch\n\n\n\n\n\n\nZend\\Mvc\\DispatchListener\n\n\nonDispatch\n\n\n\n\n\n\nZend\\Mvc\\DispatchListener\n\n\nmarshallControllerNotFoundEvent\n\n\n\n\n\n\nZend\\Mvc\\DispatchListener\n\n\nmarshallBadControllerEvent\n\n\n\n\n\n\n\n\nMvcEvent::EVENT_RENDER\n (\"render\")\n\n\nListeners\n\n\nThe following classes listen to this event (sorted from higher priority to lower\npriority):\n\n\n\n\n\n\n\n\nClass\n\n\nPriority\n\n\nMethod Called\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nZend\\Mvc\\Console\\View\\DefaultRenderingStrategy\n\n\n-10000\n\n\nrender\n\n\nRender the view.\n\n\n\n\n\n\n\n\nTriggered By\n\n\nThis event is triggered by the following classes:\n\n\n\n\n\n\n\n\nClass\n\n\nIn Method\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nZend\\Mvc\\Application\n\n\ncompleteRequest\n\n\nThis event is triggered just before the \nMvcEvent::FINISH\n event.\n\n\n\n\n\n\n\n\nMvcEvent::EVENT_RENDER_ERROR\n (\"render.error\")\n\n\nListeners\n\n\nThe following classes listen to this event (sorted from higher priority to lower\npriority):\n\n\nConsole context only\n\n\nThe following listeners are only attached in a console context:\n\n\n\n\n\n\n\n\nClass\n\n\nPriority\n\n\nMethod Called\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nZend\\Mvc\\Console\\View\\ExceptionStrategy\n\n\n1\n\n\nprepareExceptionViewModel\n\n\nCreate an exception view model.\n\n\n\n\n\n\nZend\\Mvc\\Console\\View\\InjectViewModelListener\n\n\n-100\n\n\ninjectViewModel\n\n\nInserts the \nViewModel\n (in this case, a \nZend\\Mvc\\Console\\View\\ViewModel\n) and adds it to the \nMvcEvent\n object. It either (a) adds it as a child to the default, composed view model, or (b) replaces it if the result is marked as terminable.\n\n\n\n\n\n\n\n\nTriggered By\n\n\nThis event is triggered by the following classes:\n\n\n\n\n\n\n\n\nClass\n\n\nIn Method\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nZend\\Mvc\\View\\Http\\DefaultRenderingStrategy\n\n\nrender\n\n\nThis event is triggered if an exception is raised during rendering.\n\n\n\n\n\n\n\n\nSendResponseEvent::EVENT_SEND_RESPONSE\n\n\nListeners\n\n\nThe following classes listen to this event (sorted from higher priority to lower\npriority):\n\n\n\n\n\n\n\n\nClass\n\n\nPriority\n\n\nMethod Called\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nZend\\Mvc\\Console\\ResponseSender\\ConsoleResponseSender\n\n\n-2000\n\n\n__invoke\n\n\nEmits console output.\n\n\n\n\n\n\n\n\nTriggered By\n\n\nThis event is triggered by the following classes:\n\n\n\n\n\n\n\n\nClass\n\n\nIn Method\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nZend\\Mvc\\SendResponseListener\n\n\nsendResponse\n\n\nTriggered by \nMvcEvent::FINISH\n at a priority of -10000, this listener emits the response to the client.",
            "title": "Listeners"
        },
        {
            "location": "/listeners/#mvc-listeners",
            "text": "zend-mvc-console registers a number of listeners with zend-mvc applications.\nBelow is a list of events, and the listeners zend-mvc-console registers.",
            "title": "MVC Listeners"
        },
        {
            "location": "/listeners/#mvceventevent_bootstrap-bootstrap",
            "text": "",
            "title": "MvcEvent::EVENT_BOOTSTRAP (\"bootstrap\")"
        },
        {
            "location": "/listeners/#listeners",
            "text": "The following classes listen to this event (sorted from higher priority to lower\npriority):     Class  Priority  Method Called  Triggers  Description      Zend\\Mvc\\Console\\View\\ViewManager  10000  onBootstrap  none  Prepares the view layer.",
            "title": "Listeners"
        },
        {
            "location": "/listeners/#triggered-by",
            "text": "This event is triggered by the following classes:     Class  In Method      Zend\\Mvc\\Application  bootstrap",
            "title": "Triggered By"
        },
        {
            "location": "/listeners/#mvceventevent_dispatch-dispatch",
            "text": "",
            "title": "MvcEvent::EVENT_DISPATCH (\"dispatch\")"
        },
        {
            "location": "/listeners/#listeners_1",
            "text": "The following classes listen to this event (sorted from higher priority to lower\npriority):     Class  Priority  Method Called  Description      Zend\\Mvc\\Console\\View\\InjectNamedConsoleParamsListener  1000  injectNamedParams  Merge all params (route match params and params in the command), and add them to the  Request  object.    Zend\\Mvc\\Console\\View\\CreateViewModelListener  -80  createViewModelFromArray  If the controller action returns an associative array, this listener casts it to a  Zend\\Mvc\\Console\\View\\ViewModel  object.    Zend\\Mvc\\Console\\View\\CreateViewModelListener  -80  createViewModelFromString  If the controller action returns a string, this listener casts it to a  Zend\\Mvc\\Console\\View\\ViewModel  object.    Zend\\Mvc\\Console\\View\\CreateViewModelListener  -80  createViewModelFromNull  If the controller action returns null, this listener casts it to a  Zend\\Mvc\\Console\\View\\ViewModel  object.    Zend\\Mvc\\Console\\View\\InjectViewModelListener  -100  injectViewModel  Inserts the  ViewModel  (in this case, a  Zend\\Mvc\\Console\\View\\ViewModel ) and adds it to the  MvcEvent  object. It either (a) adds it as a child to the default, composed view model, or (b) replaces it if the result is marked as terminal.",
            "title": "Listeners"
        },
        {
            "location": "/listeners/#triggered-by_1",
            "text": "This event is triggered by the following classes:     Class  In Method  Description      Zend\\Mvc\\Application  run  Uses a short circuit callback to halt propagation of the event if an error is raised during routing.    Zend\\Mvc\\Controller\\AbstractController  dispatch  If a listener returns a  Response  object, it halts propagation. Note: every  AbstractController  listens to this event and executes the  onDispatch  method when it is triggered.",
            "title": "Triggered By"
        },
        {
            "location": "/listeners/#mvceventevent_dispatch_error-dispatcherror",
            "text": "",
            "title": "MvcEvent::EVENT_DISPATCH_ERROR (\"dispatch.error\")"
        },
        {
            "location": "/listeners/#listeners_2",
            "text": "The following classes listen to this event (sorted from higher priority to lower\npriority):     Class  Priority  Method Called  Description      Zend\\Mvc\\Console\\View\\RouteNotFoundStrategy  1  handleRouteNotFoundError  Detect if an error is a \"route not found\" condition, and display a usage message.    Zend\\Mvc\\Console\\View\\ExceptionStrategy  1  prepareExceptionViewModel  Create an exception view model.    Zend\\Mvc\\Console\\View\\InjectViewModelListener  -100  injectViewModel  Inserts the  ViewModel  (in this case, a  Zend\\Mvc\\Console\\View\\ViewModel ) and adds it to the  MvcEvent  object. It either (a) adds it as a child to the default, composed view model, or (b) replaces it if the result is marked as terminable.",
            "title": "Listeners"
        },
        {
            "location": "/listeners/#triggered-by_2",
            "text": "Class  In Method      Zend\\Mvc\\MiddlewareListener  onDispatch    Zend\\Mvc\\DispatchListener  onDispatch    Zend\\Mvc\\DispatchListener  marshallControllerNotFoundEvent    Zend\\Mvc\\DispatchListener  marshallBadControllerEvent",
            "title": "Triggered By"
        },
        {
            "location": "/listeners/#mvceventevent_render-render",
            "text": "",
            "title": "MvcEvent::EVENT_RENDER (\"render\")"
        },
        {
            "location": "/listeners/#listeners_3",
            "text": "The following classes listen to this event (sorted from higher priority to lower\npriority):     Class  Priority  Method Called  Description      Zend\\Mvc\\Console\\View\\DefaultRenderingStrategy  -10000  render  Render the view.",
            "title": "Listeners"
        },
        {
            "location": "/listeners/#triggered-by_3",
            "text": "This event is triggered by the following classes:     Class  In Method  Description      Zend\\Mvc\\Application  completeRequest  This event is triggered just before the  MvcEvent::FINISH  event.",
            "title": "Triggered By"
        },
        {
            "location": "/listeners/#mvceventevent_render_error-rendererror",
            "text": "",
            "title": "MvcEvent::EVENT_RENDER_ERROR (\"render.error\")"
        },
        {
            "location": "/listeners/#listeners_4",
            "text": "The following classes listen to this event (sorted from higher priority to lower\npriority):",
            "title": "Listeners"
        },
        {
            "location": "/listeners/#console-context-only",
            "text": "The following listeners are only attached in a console context:     Class  Priority  Method Called  Description      Zend\\Mvc\\Console\\View\\ExceptionStrategy  1  prepareExceptionViewModel  Create an exception view model.    Zend\\Mvc\\Console\\View\\InjectViewModelListener  -100  injectViewModel  Inserts the  ViewModel  (in this case, a  Zend\\Mvc\\Console\\View\\ViewModel ) and adds it to the  MvcEvent  object. It either (a) adds it as a child to the default, composed view model, or (b) replaces it if the result is marked as terminable.",
            "title": "Console context only"
        },
        {
            "location": "/listeners/#triggered-by_4",
            "text": "This event is triggered by the following classes:     Class  In Method  Description      Zend\\Mvc\\View\\Http\\DefaultRenderingStrategy  render  This event is triggered if an exception is raised during rendering.",
            "title": "Triggered By"
        },
        {
            "location": "/listeners/#sendresponseeventevent_send_response",
            "text": "",
            "title": "SendResponseEvent::EVENT_SEND_RESPONSE"
        },
        {
            "location": "/listeners/#listeners_5",
            "text": "The following classes listen to this event (sorted from higher priority to lower\npriority):     Class  Priority  Method Called  Description      Zend\\Mvc\\Console\\ResponseSender\\ConsoleResponseSender  -2000  __invoke  Emits console output.",
            "title": "Listeners"
        },
        {
            "location": "/listeners/#triggered-by_5",
            "text": "This event is triggered by the following classes:     Class  In Method  Description      Zend\\Mvc\\SendResponseListener  sendResponse  Triggered by  MvcEvent::FINISH  at a priority of -10000, this listener emits the response to the client.",
            "title": "Triggered By"
        },
        {
            "location": "/services/",
            "text": "Default Services\n\n\nzend-mvc-console exists to enable legacy console tooling for zend-mvc\napplications. As such, one of its primary functions is providing services to the\nMVC layer.\n\n\nThis chapter details the various services registered by zend-mvc-console by\ndefault, the classes they represent, and any configuration options available.\n\n\nServices Provided\n\n\nThe following is a list of service names and what the service returns.\n\n\n\n\n\n\n\n\nService Name\n\n\nCreates instance of\n\n\n\n\n\n\n\n\n\n\nConsoleAdapter\n\n\nZend\\Console\\Adapter\\AdapterInterface\n\n\n\n\n\n\nConsoleExceptionStrategy\n\n\nZend\\Mvc\\Console\\View\\ExceptionStrategy\n\n\n\n\n\n\nConsoleRouteNotFoundStrategy\n\n\nZend\\Mvc\\Console\\View\\RouteNotFoundStrategy\n\n\n\n\n\n\nConsoleRouter\n\n\nZend\\Mvc\\Console\\Router\\SimpleRouteStack\n\n\n\n\n\n\nConsoleViewManager\n\n\nZend\\Mvc\\Console\\View\\ViewManager\n\n\n\n\n\n\nZend\\Mvc\\Console\\View\\DefaultRenderingStrategy\n\n\nZend\\Mvc\\Console\\View\\DefaultRenderingStrategy\n\n\n\n\n\n\nZend\\Mvc\\Console\\View\\Renderer\n\n\nZend\\Mvc\\Console\\View\\Renderer\n\n\n\n\n\n\n\n\nAliases\n\n\nThe following is a list of service aliases.\n\n\n\n\n\n\n\n\nAlias\n\n\nAliased to\n\n\n\n\n\n\n\n\n\n\nConsoleDefaultRenderingStrategy\n\n\nZend\\Mvc\\Console\\View\\DefaultRenderingStrategy\n\n\n\n\n\n\nConsoleRenderer\n\n\nZend\\Mvc\\Console\\View\\Renderer\n\n\n\n\n\n\n\n\nDelegator factories\n\n\nWhen operating in a console environment, several typical zend-mvc services need\nto operate differently, or require alternate services. To enable that,\nzend-mvc-console provides a number of \ndelegator\nfactories\n. The\nfollowing is a list of those provided, the service they override, and a\ndescription of what they do.\n\n\n\n\n\n\n\n\nService Name\n\n\nDelegator Factory\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nApplication\n\n\nZend\\Mvc\\Console\\Service\\ConsoleApplicationDelegatorFactory\n\n\nIn a console environment, attaches the \nZend\\Mvc\\Console\\View\\ViewManager\n to the application instance before returning it.\n\n\n\n\n\n\nControllerManager\n\n\nZend\\Mvc\\Console\\Service\\ControllerManagerDelegatorFactory\n\n\nAttaches an initializer for injecting \nAbstractConsoleController\n instances with a console adapter.\n\n\n\n\n\n\nControllerPluginManager\n\n\nZend\\Mvc\\Console\\Service\\ControllerPluginManagerDelegatorFactory\n\n\nInjects the \nCreateConsoleNotFoundModel\n plugin into the controller \nPluginManager\n.\n\n\n\n\n\n\nRequest\n\n\nZend\\Mvc\\Console\\Service\\ConsoleRequestDelegatorFactory\n\n\nIf a console environment is detected, replaces the request with a \nZend\\Console\\Request\n.\n\n\n\n\n\n\nResponse\n\n\nZend\\Mvc\\Console\\Service\\ConsoleResponseDelegatorFactory\n\n\nIf a console environment is detected, replaces the response with a \nZend\\Console\\Response\n.\n\n\n\n\n\n\nRouter\n\n\nZend\\Mvc\\Console\\Router\\ConsoleRouterDelegatorFactory\n\n\nIf a console environment is detected, replaces the router with the \nConsoleRouter\n service.\n\n\n\n\n\n\nZend\\Mvc\\SendResponseListener\n\n\nZend\\Mvc\\Console\\Service\\ConsoleResponseSenderDelegatorFactory\n\n\nIf a console environment is detected, attaches the \nZend\\Mvc\\Console\\ResponseSender\\ConsoleResponseSender\n to the \nSendResponseListener\n.\n\n\n\n\n\n\nViewHelperManager\n\n\nZend\\Mvc\\Console\\Service\\ConsoleViewHelperManagerDelegatorFactory\n\n\nIf a console environment is detected, injects override factories for the \nurl\n and \nbasePath\n view helpers into the \nHelperPluginManager\n.\n\n\n\n\n\n\n\n\nApplication Configuration Options\n\n\nConsole tooling provides several locations for configuration, primarily at the\nservice, routing, and view levels.\n\n\nServices\n\n\nAll services registered can be configured to use different factories; see the\nabove tables for details on what service names to override.\n\n\nRouting\n\n\nRouting configuration is detailed in the \nrouting chapter\n.\n\n\nViewManager\n\n\nZend\\Mvc\\Console\\View\\ViewManager\n acts similarly to its \nzend-mvc\nequivalent\n, and\nwill look for one or the other of the following configuration structures:\n\n\nreturn [\n    'view_manager' => [\n        'mvc_strategies' => $stringOrArrayOfMvcListenerServiceNames,\n        'strategies'     => $stringOrArrayOfViewListenerServiceNames,\n    ],\n    'console'      => [\n        'view_manager' => [\n            'mvc_strategies' => $stringOrArrayOfMvcListenerServiceNames,\n            'strategies'     => $stringOrArrayOfViewListenerServiceNames,\n        ],\n    ],\n];\n\n\n\nPreference is given to those under the \nconsole\n top-level key (those under\n\nview_manager\n are ignored if the \nconsole.view_manager\n structure exists).\n\n\nmvc_strategies\n refers to view-related listeners that need to operate on the\n\nZend\\Mvc\\MvcEvent\n context. \nstrategies\n refers to view-related listeners that operate\non the \nZend\\View\\ViewEvent\n context.",
            "title": "Default Services"
        },
        {
            "location": "/services/#default-services",
            "text": "zend-mvc-console exists to enable legacy console tooling for zend-mvc\napplications. As such, one of its primary functions is providing services to the\nMVC layer.  This chapter details the various services registered by zend-mvc-console by\ndefault, the classes they represent, and any configuration options available.",
            "title": "Default Services"
        },
        {
            "location": "/services/#services-provided",
            "text": "The following is a list of service names and what the service returns.     Service Name  Creates instance of      ConsoleAdapter  Zend\\Console\\Adapter\\AdapterInterface    ConsoleExceptionStrategy  Zend\\Mvc\\Console\\View\\ExceptionStrategy    ConsoleRouteNotFoundStrategy  Zend\\Mvc\\Console\\View\\RouteNotFoundStrategy    ConsoleRouter  Zend\\Mvc\\Console\\Router\\SimpleRouteStack    ConsoleViewManager  Zend\\Mvc\\Console\\View\\ViewManager    Zend\\Mvc\\Console\\View\\DefaultRenderingStrategy  Zend\\Mvc\\Console\\View\\DefaultRenderingStrategy    Zend\\Mvc\\Console\\View\\Renderer  Zend\\Mvc\\Console\\View\\Renderer",
            "title": "Services Provided"
        },
        {
            "location": "/services/#aliases",
            "text": "The following is a list of service aliases.     Alias  Aliased to      ConsoleDefaultRenderingStrategy  Zend\\Mvc\\Console\\View\\DefaultRenderingStrategy    ConsoleRenderer  Zend\\Mvc\\Console\\View\\Renderer",
            "title": "Aliases"
        },
        {
            "location": "/services/#delegator-factories",
            "text": "When operating in a console environment, several typical zend-mvc services need\nto operate differently, or require alternate services. To enable that,\nzend-mvc-console provides a number of  delegator\nfactories . The\nfollowing is a list of those provided, the service they override, and a\ndescription of what they do.     Service Name  Delegator Factory  Description      Application  Zend\\Mvc\\Console\\Service\\ConsoleApplicationDelegatorFactory  In a console environment, attaches the  Zend\\Mvc\\Console\\View\\ViewManager  to the application instance before returning it.    ControllerManager  Zend\\Mvc\\Console\\Service\\ControllerManagerDelegatorFactory  Attaches an initializer for injecting  AbstractConsoleController  instances with a console adapter.    ControllerPluginManager  Zend\\Mvc\\Console\\Service\\ControllerPluginManagerDelegatorFactory  Injects the  CreateConsoleNotFoundModel  plugin into the controller  PluginManager .    Request  Zend\\Mvc\\Console\\Service\\ConsoleRequestDelegatorFactory  If a console environment is detected, replaces the request with a  Zend\\Console\\Request .    Response  Zend\\Mvc\\Console\\Service\\ConsoleResponseDelegatorFactory  If a console environment is detected, replaces the response with a  Zend\\Console\\Response .    Router  Zend\\Mvc\\Console\\Router\\ConsoleRouterDelegatorFactory  If a console environment is detected, replaces the router with the  ConsoleRouter  service.    Zend\\Mvc\\SendResponseListener  Zend\\Mvc\\Console\\Service\\ConsoleResponseSenderDelegatorFactory  If a console environment is detected, attaches the  Zend\\Mvc\\Console\\ResponseSender\\ConsoleResponseSender  to the  SendResponseListener .    ViewHelperManager  Zend\\Mvc\\Console\\Service\\ConsoleViewHelperManagerDelegatorFactory  If a console environment is detected, injects override factories for the  url  and  basePath  view helpers into the  HelperPluginManager .",
            "title": "Delegator factories"
        },
        {
            "location": "/services/#application-configuration-options",
            "text": "Console tooling provides several locations for configuration, primarily at the\nservice, routing, and view levels.",
            "title": "Application Configuration Options"
        },
        {
            "location": "/services/#services",
            "text": "All services registered can be configured to use different factories; see the\nabove tables for details on what service names to override.",
            "title": "Services"
        },
        {
            "location": "/services/#routing",
            "text": "Routing configuration is detailed in the  routing chapter .",
            "title": "Routing"
        },
        {
            "location": "/services/#viewmanager",
            "text": "Zend\\Mvc\\Console\\View\\ViewManager  acts similarly to its  zend-mvc\nequivalent , and\nwill look for one or the other of the following configuration structures:  return [\n    'view_manager' => [\n        'mvc_strategies' => $stringOrArrayOfMvcListenerServiceNames,\n        'strategies'     => $stringOrArrayOfViewListenerServiceNames,\n    ],\n    'console'      => [\n        'view_manager' => [\n            'mvc_strategies' => $stringOrArrayOfMvcListenerServiceNames,\n            'strategies'     => $stringOrArrayOfViewListenerServiceNames,\n        ],\n    ],\n];  Preference is given to those under the  console  top-level key (those under view_manager  are ignored if the  console.view_manager  structure exists).  mvc_strategies  refers to view-related listeners that need to operate on the Zend\\Mvc\\MvcEvent  context.  strategies  refers to view-related listeners that operate\non the  Zend\\View\\ViewEvent  context.",
            "title": "ViewManager"
        },
        {
            "location": "/migration/v2-to-v3/",
            "text": "Migration: zend-mvc and zend-view v2 to zend-mvc-console\n\n\nzend-mvc-console ports all console functionality from zend-mvc and zend-view v2\nreleases to a single component. As such, a number of classes were renamed that\nmay impact end-users.\n\n\nzend-mvc functionality\n\n\nAbstractConsoleController\n\n\nZend\\Mvc\\Controller\\AbstractConsoleController\n becomes\n\nZend\\Mvc\\Console\\Controller\\AbstractConsoleController\n. Otherwise, all\nfunctionality remains the same.\n\n\nUpdate your code to import the \nAbstractConsoleController\n under its new\nnamespace.\n\n\nRouting\n\n\nThe namespace \nZend\\Mvc\\Router\\Console\n becomes \nZend\\Mvc\\Console\\Router\n. All\nclasses retain existing functionality. If you were using default routes\n(\nSimple\n) or using the short names to refer to console routes, no changes will\nbe necessary. Otherwise, update your code to refer to the new namespace.\n\n\nResponseSender\n\n\nZend\\Mvc\\ResponseSender\\ConsoleResponseSender\n becomes\n\nZend\\Mvc\\Console\\ResponseSender\\ConsoleResponseSender\n. As this is an\nimplementation detail, it should have no impact on the end-user.\n\n\nListeners\n\n\nThe \nZend\\Mvc\\View\\Console\n namespace becomes \nZend\\Mvc\\Console\\View\n, but all\nexisting listeners retain their names and functionality. As these were all\nmanaged by the console-specific \nViewManager\n, this change should have no impact\non the end-user unless:\n\n\n\n\nany of these classes were being extended\n\n\nany custom factories were being used to provide the services (specifically the\n  \nConsoleRouteNotFoundStrategy\n, \nConsoleExceptionStrategy\n, and\n  \nConsoleDefaultRenderingStrategy\n).\n\n\n\n\nIn such cases, you will need to update your code to reference the new namespace.\n\n\nzend-view functionality\n\n\nViewModel\n\n\nzend-view provided a \nZend\\View\\Model\\ConsoleModel\n class. This is now\n\nZend\\Mvc\\Console\\View\\ViewModel\n. If you were returning \nConsoleModel\n\npreviously, update your code to return the new version.\n\n\nRenderer\n\n\nzend-view provided a \nZend\\View\\Renderer\\ConsoleRenderer\n class. This is now\n\nZend\\Mvc\\Console\\View\\Renderer\n. Additionally, the console-specific\n\nDefaultRenderingStrategy\n now consumes the renderer (it did not in version 2).",
            "title": "Version 2 to Version 3"
        },
        {
            "location": "/migration/v2-to-v3/#migration-zend-mvc-and-zend-view-v2-to-zend-mvc-console",
            "text": "zend-mvc-console ports all console functionality from zend-mvc and zend-view v2\nreleases to a single component. As such, a number of classes were renamed that\nmay impact end-users.",
            "title": "Migration: zend-mvc and zend-view v2 to zend-mvc-console"
        },
        {
            "location": "/migration/v2-to-v3/#zend-mvc-functionality",
            "text": "",
            "title": "zend-mvc functionality"
        },
        {
            "location": "/migration/v2-to-v3/#abstractconsolecontroller",
            "text": "Zend\\Mvc\\Controller\\AbstractConsoleController  becomes Zend\\Mvc\\Console\\Controller\\AbstractConsoleController . Otherwise, all\nfunctionality remains the same.  Update your code to import the  AbstractConsoleController  under its new\nnamespace.",
            "title": "AbstractConsoleController"
        },
        {
            "location": "/migration/v2-to-v3/#routing",
            "text": "The namespace  Zend\\Mvc\\Router\\Console  becomes  Zend\\Mvc\\Console\\Router . All\nclasses retain existing functionality. If you were using default routes\n( Simple ) or using the short names to refer to console routes, no changes will\nbe necessary. Otherwise, update your code to refer to the new namespace.",
            "title": "Routing"
        },
        {
            "location": "/migration/v2-to-v3/#responsesender",
            "text": "Zend\\Mvc\\ResponseSender\\ConsoleResponseSender  becomes Zend\\Mvc\\Console\\ResponseSender\\ConsoleResponseSender . As this is an\nimplementation detail, it should have no impact on the end-user.",
            "title": "ResponseSender"
        },
        {
            "location": "/migration/v2-to-v3/#listeners",
            "text": "The  Zend\\Mvc\\View\\Console  namespace becomes  Zend\\Mvc\\Console\\View , but all\nexisting listeners retain their names and functionality. As these were all\nmanaged by the console-specific  ViewManager , this change should have no impact\non the end-user unless:   any of these classes were being extended  any custom factories were being used to provide the services (specifically the\n   ConsoleRouteNotFoundStrategy ,  ConsoleExceptionStrategy , and\n   ConsoleDefaultRenderingStrategy ).   In such cases, you will need to update your code to reference the new namespace.",
            "title": "Listeners"
        },
        {
            "location": "/migration/v2-to-v3/#zend-view-functionality",
            "text": "",
            "title": "zend-view functionality"
        },
        {
            "location": "/migration/v2-to-v3/#viewmodel",
            "text": "zend-view provided a  Zend\\View\\Model\\ConsoleModel  class. This is now Zend\\Mvc\\Console\\View\\ViewModel . If you were returning  ConsoleModel \npreviously, update your code to return the new version.",
            "title": "ViewModel"
        },
        {
            "location": "/migration/v2-to-v3/#renderer",
            "text": "zend-view provided a  Zend\\View\\Renderer\\ConsoleRenderer  class. This is now Zend\\Mvc\\Console\\View\\Renderer . Additionally, the console-specific DefaultRenderingStrategy  now consumes the renderer (it did not in version 2).",
            "title": "Renderer"
        }
    ]
}